<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[属性的行为(未校对)]]></title>
    <url>%2F113017%2FDealing-with-Properties-Uncalibrated%2F</url>
    <content type="text"><![CDATA[属性的行为(未校对)Martin Fowlerfowler@acm.org几乎你创建的每个对象都需要属性：关于对象的一些声明。一个人可能有一个高度，一个公司可能有一个CEO，一个航班可能有一个航班号。有很多方法来建模属性。在这篇文章中，我将探讨其中一些方法，当你可能想要使用它们。我经常看到图案触及这个主题，但他们通常只涉及部分图片。在这里，我想更广泛地讨论这个问题，以便更好地讨论这些选项。最常见和最简单的情况是使用固定属性，即只声明类的属性。在绝大多数情况下，你只需要做。固定属性在有大量固定属性时会失败，或者需要频繁更改，可能在运行时。这些力量带领您到各种各样的动态财产。所有动态属性都具有参数化属性的质量，在这里查询需要使用带有参数的查询方法的属性。其中最简单的是灵活的动态属性，其中参数只是一个字符串。这使得定义和使用属性变得容易，但难以控制。如果您需要该控件，则可以使用“定义的动态属性”，其中参数必须是某个类的实例。进一步的控制步骤允许您强有力地键入您的动态属性与类型动态属性。随着您的财产结构变得越来越复杂，您应该考虑将它们设置为“单独属性”，从而使属性成为一个对象。如果你需要多值属性，你可以考虑一个类型化的关系。在这个主题中最复杂的例子是你想要规则来控制什么类型的对象具有什么样的属性 - 这需要动态属性知识水平。另一种属性完全是外部属性（Extrinsic Property），如果你想给一个对象一个属性，但是不改变它的接口来支持它，那么就是你使用的一种模式。ProblemSolutionNamepage&nbsp;给它一个这个事实的特定属性。这将转化为查询方法，并可能是一种编程语言的更新方法.固定属性4&nbsp;提供可参数化的属性，可以根据参数表示不同的属性动态属性4&nbsp;提供一个用字符串参数化的属性。声明一个属性只是使用字符串.灵活的动态属性5&nbsp;提供用某种类型的实例参数化的属性。要声明属性，请创建该类型的新实例定义的动态属性7&nbsp;提供使用某种类型的实例进行参数化的属性。要声明属性，请创建该类型的新实例并指定该属性的值类型.类型动态属性9你如何代表一个事物的事实，并允许事实记录有关的事实为每个属性创建一个单独的对象。 关于那个财产的事实可以作为这个财产的属性分开的属性10你如何表示两个对象之间的关系（如何表示多值动态属性？）为两个对象之间的每个链接创建一个关系对象。 给关系对象一个类型对象来表示关系的含义。 （类型对象是多值属性的名称。）类型关系14当你使用动态属性时，你如何强制某些类型的对象具有某些属性？创建知识级别以包含哪些类型的对象使用哪些类型的属性的规则动态财产知识水平16你如何给一个对象一个属性而不改变它的接口？使另一个对象负责知道属性外在性质18什么是属性这不是一个愚蠢的问题。当人们围绕“属性”这个词来分支时，他们可能意味着很多不同的东西。对某些属性来说，是一个类的实例变量或数据成员。对于其他人来说，它们就像UML图中的一个盒子一样。所以在我开始这篇文章之前，我必须定义这个词的用法。为了我的目的，一个属性是关于一个可以通过查询方法获得的对象的一些信息。它可能是一个值类型（如Java中的int）或一个类的实例。您可能能够更新该属性，但不一定。您可以在创建对象时设置属性，但不一定。该属性可以作为实例变量或数据成员存储，但不一定是。班级可能会从另一个班级获得价值，或者经过一些进一步的计算。因此，我采用属性的接口视图而不是实现视图。这是我在设计中经常使用的习惯：对于我来说，面向对象的本质是将接口与实现分开，并使接口更加重要。固定属性固定属性是我们使用的最常见的属性。 固定属性在类型的接口中声明。 它给出了属性的名称和返回类型。 图1显示了使用UML建模的属性，清单1显示了这些属性的查询方法如何在Java中显示。 我已经选择了这个例子来说明这个讨论同样适用于UML属性和UML关联。 它也适用于计算值（年龄）以及那些合理存储的数据（出生日期）。图1.使用固定属性建模的人员1234567class Person &#123;public Date getDateOfBirth(); public int getAge();public Quantity getHeight(); public Company getEmployer();public void setDateOfBirth (Date newDateOfBirth); public void setEmployer (Company newEmployer);列举,图1的java操作查询操作通常遵循一些命名约定。在smalltalk中，您总是在属性名称（dateOfBirth）之后命名查询。 C ++从来没有一个固定的约定，有些人只是在属性后面命名，而另一些人则使用“get”约定（getDateOfBirth）。 Java从没有特别的约定开始，但现在大多数人都采用get约定。就我个人而言，当您阅读代码时，我发现“get”令人恼火，所以我宁愿忽略它，但Java风格是使用get，所以现在就使用它。无论您使用的是存储值还是派生值，都应确保遵循相同的约定。人类的客户不应该知道或关心年龄是否存储或派生。修饰符操作的存在取决于您是否希望直接修改值。如果你这样做，那么你会根据一些命名方案，例如setDateOfBirth（Date）提供一个修饰符操作。对于返回值存在不同的约定。你可以返回属性的新值（Date），被修改的对象（Person），或者什么都没有（void）。我更愿意在修饰符上返回void，以帮助明确修饰符和查询之间的区别。1234 固定属性你如何代表一个对象的事实？给它一个这个事实的特定属性。 这将转化为查询方法，并可能是一种编程语言的更新方法。 √ 清晰的界面 × 只能在设计时添加属性您可能希望为属性的构造函数提供参数。通常，您要在构造函数中设置足够的属性，以便构建格式良好的类。不想直接修改的属性不应该有修饰符操作。如果您只希望从出生之日起计算，那么年龄属性可能就是这种情况。对于一个不可改变的属性也是如此：一个在类的生命周期中不会改变的属性。当你想使财产不可改变时，请记住考虑到人为错误。虽然出生日期对于现实世界中的人类来说是不可改变的属性，但是您可能会在输入到计算机系统时出现错误，从而使其变得可变。软件常常模拟我们所知道的世界，而不是世界本身。固定属性是迄今为止您将遇到的最常见的属性形式。他们这样做是有原因的：他们使用简单方便。您应该使用固定属性作为表示属性的第一个也是最常见的选择。在本文中，我将给出许多固定属性的替代方案。在某些情况下，这些替代品更好，但大多数情况下不是。请记住，当我们经历的选择。我99％的时间使用固定的属性。其他品种更为复杂，这就是为什么我把这篇论文的大部分花费在他们身上 - 也是为什么我不愿意使用它们！动态属性固定属性的关键在于您在设计时修复了这些属性，并且所有实例在运行时都必须遵循该决定。 对于一些问题，这是一个尴尬的限制。 想象一下，我们正在建立一个复杂的联络系统。 有一些东西是固定的：家庭住址，家庭和工作电话，电子邮件。 但他们是各种各样的小变化。 对于需要记录父母地址的人，另一个人有白天工作和晚上工作号码。 事先很难预测所有这些事情，每次更改系统时都必须经过编译，测试和分发。 要处理这个问题，你需要使用动态属性。12345动态属性你如何代表一个对象的事实？提供可参数化的属性，可以根据参数表示不同的属性 √ 可以在运行时添加属性× 不清楚的界面动态属性有多种变化，每种变化都会在灵活性和安全性之间做出不同的折衷。 最简单的方法是灵活的动态属性。 这种模式的本质是为键值为简单值的人（通常是字符串）添加一个合格的关联（参见图2和清单2）。 如果您想为某人Kent添加休假地址，则只需使用清单3中的代码即可。您不需要重新编译人员类。 你甚至可以建立一个图形用户界面（GUI）或者文件读取器来添加属性，而不用重新编译客户端。图2.使用动态属性建模的人员123class Person &#123;public Object getValueOf(String key);public void setValueOf(String key, Object value);列举2,图2的java方法12kent.setValueOf(“VacationAddress”, anAddress);Address kentVactation = (Address) kent.getValueOf(“VacationAddress”)列举3,使用动态属性这样说，你可能想知道为什么有人会使用固定的属性，因为动态的像这样的属性给了你更多的灵活性。当然有一个成本，它在于软件各部分之间依赖关系的清晰度降低。这一切都非常好好给一个人增加一个度假地址属性，但是你怎么知道把它重新取回呢？有了固定的属性，你可以看看人的界面，看看属性。该编译器可以检查不要求对象做不理解的事情。 用一个动态属性，你不能做任何设计时检查。此外的界面人很难看。不只是你看Person的声明接口 -你也必须找到不会出现在类接口中的动态属性。你必须找到那些设置属性的代码部分（通常不会在Person类中）挖出来123灵活的动态属性你如何代表一个对象的事实？提供一个用字符串参数化的属性。 只声明一个属性使用字符串。不仅是财产很难找到，它也创造了噩梦的依赖。随着固定属性的客户端代码有一个依赖于人类 - 一个依赖是很容易的不要跟丢。如果你改变属性的名字，编译器会让你知道，并告诉你需要改变什么代码才能解决问题。但灵活的动态属性创建一个依赖于任意一段代码。它可能是属于一个类的代码甚至不能被客户看到。如果有人更改密钥字符串会发生什么？什么如果有人改变他们把键入字符串的对象的类型会发生？不只是可以的编译器无助于你，你甚至不知道从哪里开始寻找潜力变化。灵活的动态属性在最极端的情况下显示了这个问题。该物业可能是Person的任何客户在设计时创建。如果另一个人的客户使用同样的东西©Martin Fowler 1997 6属性你有一个很难找到的两个类之间的依赖关系。此外属性可以在运行时通过读取文件或通过GUI添加。不可能发现，即使在运行时，一个人的法律动态属性是什么。诚然，你可以问一个人，如果它有一个度假地址的财产-但如果没有一个这是否意味着这一点人没有假期地址，或者是否意味着没有这样的财产度假地址？如果现在没有这样的财产，那并不代表就没有这个财产几秒钟后。灵活动态特性的另一个关键缺点是很难替代它们进行操作。封装的一个关键优势是使用属性的客户端无法分辨它是作为对象数据的一部分存储的，还是通过方法来计算的。这是一个对象方法非常重要的一部分。它可以让你不只是一个普通的界面目的，而且在客户不知情的情况下改变主意。在……的存在下子类型，你甚至可以有一个超类型存储属性和子类计算或副反之亦然。但是，如果要使用动态属性，则只能更改存储的数据一个计算就是在通用访问器中为动态属性设置一个特定的陷阱清单4中的代码。这个代码可能很脆弱，难以维护。12345class Person &#123;public Object getValueOf (String key) &#123;if (key = “vacationAddress”) return calculatedVacationAddress();if (key = “vacationPhone”) return getVacationPhone();// else return stored value…列举4,用操作替换动态属性其他形式的动态属性可以帮助您解决其中一些问题，但不是全部。该动态属性的根本缺点是你失去了清晰的界面和所有的设计时间检查。动态属性的不同方法给你不同的能力运行时检查。如果你需要动态属性，并且当然有确定的情况你这样做，那么你只需要放弃设计时间检查和明确的设计时间接口。唯一的问题是如何明确界面和多少检查你可以做的在运行时。使用灵活的动态属性，你也不会得到任何一个。你经常在数据库中发现动态属性，因为改变它通常是一个痛苦数据库模式，特别是如果有大量的数据迁移。分布式的接口例如在CORBA中的组件也经常因为相似的原因而使用动态属性。那里是很多使用界面的远程客户，所以你不愿意改变它。在这两个这些情况并不是编译时和运行时间的区别，而是一个区别设计时间和生产之间的区别。如果你正在做的是通过GUI显示和更新信息，而代码永远不会对键进行固定的引用（即，你永远不会看到像清单3那样的代码），那么你很漂亮安全，灵活的动态属性。这是因为你没有建立一个讨厌的依赖以一些任意字符串作为关键字。否则，你应该考虑其他方法之一动态属性。更多运行时检查的第一步是定义的动态属性。钥匙定义相对于灵活的动态属性之间的区别是所使用的关键动态属性不再是一些任意的字符串，而是现在某个类的一个实例（图3）。图3.定义的动态属性-在它的表面上使用定义的动态属性并没有太大的改变。确实是代码接口几乎相同（清单5和清单6）。但现在不再选择密钥完全是任意的，它受到接触类型的限制。当然这仍然允许你在运行时添加属性-只需创建一个新的联系人类型。但现在至少有某处可以找到一个潜在的钥匙清单，而不必拖网程序文本。在设计时添加的任何密钥都可以在加载程序中收集接触式类。 您可以轻松地提供服务，以在运行时查找合法的密钥。123class Person &#123;public Object getValueOf(ContactType key);public void setValueOf(ContactType key, Object value);列举5, 图3的Java接口1234class ContactType &#123;public static Enumeration instances();public static boolean hasInstanceNamed(String name);public static ContactType get(String name);列举6,为定义的属性类型提供的服务特别是你现在可以设置一些检查，以防止由于某人要求的错误动态属性不存在，如清单7所示。我抛出一个未经检查的异常这里是因为我认为get（）的前提是客户端提供了一个合法的名字对于联系人类型。客户可以通过使用来始终履行这个责任hasInstanceNamed（），但大多数时候客户端软件会挂在联系人类型上对象，而不是字符串。123定义的动态属性你如何代表一个对象的事实？提供用某种类型的实例参数化的属性。 至声明一个属性创建一个新类型的实例通常，联系人类型将保存在字典中，通常由字符串索引。这个字典可能是一个静态的联系人类型的字段，但是我更愿意把它作为注册服务器上的字段。删除联系人类型仍然具有尴尬的后果。在java中的动态属性仍然会出现在那些拥有它们的物体上，除非你写了一些复杂的东西清理代码。我通常会规定永远不要删除DefinedDynamic的键属性。 如果你想使用一个新的名字，你可以很容易地通过给它一个别名的联系人类型名字，但多次放入定义字典中。123456789class ContactType &#123;public static ContactType get(String name) &#123;if (! hasInstanceNamed (name)) throw new IllegalArgumentException(“Nosuch contact type);// return the contact type&#125;// use withAddress kentVactation =(Address) kent.getValueOf(ContactType.get(“VacationAddress”));列举7, 检查使用合法合同类型在这一点上，你可能想知道这与概念建模有什么关系，毕竟我写了很多代码并讨论设计的权衡。这是一个重要的概念上的问题，因为你所做的概念选择会影响执行选项你有。如果你选择在你的概念模型中使用灵活的动态属性，你是使你很难在你的定义中使用定义的动态属性或固定属性实现。你做概念模型的原因之一是探索什么是固定的用户的概念有什么变化。如果全面的灵活性是我唯一的目标，那么我会总是使用图4.通过这个，我可以模拟世界上的任何情况。但是这个模型不是很有用。它的无用性来自事实，它不表示什么是固定的。什么时候你正在做一个概念模型，你需要知道你的选择如何影响事物实施-否则你放弃你作为建模者的责任。我经常发现人们发现动态属性，然后想要在任何地方使用它们。灵活性如此之大，他们获得了所有的可扩展性。是的，有时候你需要动态属性。但永远不会忘记有一个价格。只有当你真的使用它们需要他们。毕竟，如果必须，以后很容易添加它们。图4.一个可以无用建模任何域的模型定义的动态属性允许您更多地指出您的属性有。这些属性仍然是无类型的。你不能执行假期的价值图3中的地址是一个地址。 你可以通过使用类型动态来做些什么属性。图5.为使用限定关联的类型化动态属性建模-类型化动态属性将类型信息添加到定义的动态属性（图6和6）图5）。这里的联系人类型的实例不只是指出该人是什么合适的人有，他们也表示每个财产的类型。 类型约束的价值，沿线清单9。123456class Person &#123;public Object getValueOf(ContactType key);public void setValueOf(ContactType key, Object value);class ContactType &#123;public Class getValueType();public ContactType (String name, Class valueType);列举8, 键入动态属性的操作12345class Person &#123;public void setValueOf(ContactType key, Object value) &#123;if (! key.getValueType().isInstance(value))throw IllegalArgumentException (“Incorrect type for property”);// set the value列举9, 做类型检查这样做类型检查可以帮助避免错误，但是仍然不够明确属性。检查是在运行时间，而不是在设计时间，因此没有那么有效。还是比没有检查好，尤其是如果你习惯于强类型的话环境。123类型动态属性你如何代表一个对象的事实？提供使用某种类型的实例进行参数化的属性。 声明一个属性创建一个新类型的实例并指定值的类型属性。当我们深入研究动态属性时，我们发现了更加丰富的反射的例子当我们获得能够描述的运行时对象时出现的架构模式他们自己。 [POSA]比我打算在这里更详细地讨论反思。动态属性提供反射功能，即使在那些不支持的语言中也是如此反思自己。即使用一种语言，也反映了一些思考的动态属性更专注 - 所以你可以提供一个更易于使用的界面。使用所有这些合格的协会可能会很难遵循。 另一种方式提供类型化的动态属性是使用单独的属性模式。 的本质单独的属性模式是它使属性成为它自己的一个对象（图6和6）清单10）。你可以得到一个人的财产，然后与每个财产得到价值和类型信息。123分开的属性你如何代表一个事物的事实，并允许事实记录这个事实为每个属性创建一个单独的对象。 有关该财产的事实可以然后被做成那个对象的属性。独立的属性和合格的关联是两种可供选择的选择动态属性。到目前为止，我已经描述了灵活和定义的动态属性合格的协会，因为合格的协会提供了一个更容易使用的界面。如果您愿意，您可以使用灵活和定义的具有单独属性的动态属性，虽然我不打算在这里进入。当我们谈到类型动态的复杂性时属性和分开的财产风格变得更有优势。图6.为分类的动态属性建模，使用单独的属性123456class Person &#123;public Enumeration getProperties();class ContactProperty &#123;public Object getValue();public Class getType();public ContactType getIndex();列举10, 使用单独属性的类型化动态属性的操作单独的属性和有限的关联不是相互排斥的。你可以很容易同时提供两个接口。这样你就得到了两者的优点。当然这使得界面更加复杂，所以首先要考虑人的客户需要什么。给他们他们需要的接口，不要让它过于复杂。但如果他们需要两个合格的协会和单独的财产，那么这是一个合理的选择。我会通常总是使用有价值的关联来获得价值，但它可能没有多少意义方式。您也可以在这里考虑接口/实现的差异。在本文中，我想专注于概念-映射到软件界面而不是其界面实现。但值得一提的是，你可以提供一个合格的协会接口，同时在实现中使用单独的对象。你只使用单独的如果一个人的客户端可以获得一个联系人属性对象，则在界面中的属性。通常是这样有助于隐藏单独的属性来简化客户端的接口。独立属性的一大优势是它可以让你放置信息关于财产的财产。这些信息可能包括谁决定的财产，何时确定，等等。 [Fowler AP§3.5]中的观察模式在一定的深度上建立在这个主题上。我在这里描述的很多东西如果你需要单独的属性，观察是值得考虑的。 （我看到了观察模式作为独立属性的使用。）您可能想知道单独的属性（一个模式）与合格的对比关联（一个UML建模结构）。你也可以把有资格的协会想象成一个模式，关联模式。事实上，我在[FowlerAP§15.2]中做了这个。我找到了有助于将建模作为模式来思考，因为这有助于我考虑权衡在使用它们。当你比较它们的东西时，这是特别有用的更清晰的模式，如单独的财产。当然，以模式开始的事情可以被转换成建模结构，特别是如果你使用UML原型。历史悠久映射模式[FowlerAP§15.3]就是一个很好的例子。我代表那个使用“历史”刻板印象。这是一个模式或建模？也许这是一个地板蜡和一个沙漠也打顶了。具有多值关联的动态属性我上面的例子集中在每个密钥都有一个单一值的情况动态属性。但是你也可以有一些情况，其中有多个项目动态属性。与人，你可能会考虑一个多值的朋友财产。有两种方法可以解决这个问题，一个简单而不令人满意，另一个就是这样满足，但（太）复杂。简单的方法就是说动态属性的值可以是一个集合。然后我们可以像使用相同接口的其他对象一样操作它（清单11）。这是好，简单，因为我们不必对基本的动态属性模式做任何事情。（这里的例子是一个类型化的动态属性，但它可以和所有的一起工作）但是，这并不令人满意，因为这不是我们想要处理多重价值的方式属性。如果朋友是一个固定的财产，我们会想沿着一个界面清单12.我不喜欢在这种情况下暴露vector。通过这样做，人类失去了当我们添加或移除元素时能够反应。这也消除了我们改变的能力我们正在使用的收集类型。1234567Person aPerson = new Person();ContactType friends = new ContactType(“Friends”, Class.forName(“Vector”));Person martin = new Person(“Martin”);martin.setValueOf(“Friends”, new Vector());Person kent = new Person(“Kent”);martin.getValueOf(“Friends”).addElement(“Kent”);Enumeration friends = martin.getValueOf(“Friends”).elements();列举11, 在类型化动态属性中使用集合值1234class Person &#123;public Enumeration getFriends();public void addFriend(Person arg);public void removeFriend(Person arg);列举12, 一个固定的多值财产的运作那么当我们有动态属性的时候，我们可以按照清单12的方式获得一个接口吗？那么，如果我们努力工作，就可以如图7所示。但这是一个复杂的模型。同一些聪明的编码，我们可以隐藏接口之后的复杂性（清单13和13）清单14），并且使用起来相当方便（清单15）。但客户仍然需要知道哪些属性是单值的，哪些属性是多值的，所有的检查正确的使用只能在运行时发生。 所有这些复杂性是痛苦的 - 更加痛苦比使用固定的属性。我会非常不愿走这么远。图7.满足对多值动态属性的过度支持1234567891011class Personpublic Object getValueOf(ContactType key);public Enumeration getValuesOf(ContactType key);public void setValueOf(ContactType key, Object newValue);public void addValueTo(ContactType key, Object newValue);public void removeValueFrom(ContactType key, Object newValue);class ContactTypepublic Class getValueType();public boolean isMultiValued();public boolean isSingleValued();public ContactType(String name, Class valueType, boolean isMultiValued);列举13, 图7的操作123456789101112class Personpublic Object getValueOf(ContactType key) &#123;if (key.isMultiValued())throw IllegalArgumentException(“should use getValuesOf()”)//return the value&#125;public void addValueTo(ContactType key, Object newValue) &#123;if (key.isSingleValued())throw IllegalArgumentException(“should use setValueOf”);if (! key.getValueType().isInstance(newValue))throw IllegalArgumentException (“Incorrect type for property”);//add the value to the collection列举14, 检查清单13的操作的使用情况123456fax = new ContactType(“fax”, Class.forName(“PhoneNumber”), false);Person martin = new Person(“martin”);martin.setValueOf(“fax”, new PhoneNumber(“123 1234”);martinFax = martin.getValueOf(“fax”);friends = new ContactType (“friends”, Class.forName(“Person”), true);martin.addValueTo(“friends”, new Person(“Kent”));列举15, 使用清单13的操作出现这种复杂性是因为我们既有多值也有单值属性。处理这些问题有一个固有的不同的界面，因此复杂性。 的当然，我们可以得到只有多值属性的情况。 这是一个常见的模式类型化关系模式（图8）。 这里一个人可能有不同的数目与一些不同公司的雇佣关系（甚至与几家公司的雇佣关系）同一家公司）。图8.类型关系的一个例子1234567class Employment &#123;public Employment (Person person, Company company, Employment Type type);public void terminate()…&#125;class Person &#123;public Enumeration getEmployments();public void addEmployment (Company company, EmploymentType type);列举15, 图8的Java接口正如我们想到的那样，它很快就会发生，这与使用a非常类似定义的动态属性是多值的，但使用分离属性来表示比合格的协会。 （或者这句话太过分了吗？）确实如此9显示了在这种情况下如何使用Defined Dynamic Property接口。 这个观点事情是真的，所以一个类型化的关系不会添加任何新的模式语言。但是类型化的关系在建模界是一个非常普遍的模式，而且很多可能没有意识到它与动态属性模式的联系。12345类型关系你如何表示两个对象之间的关系？（你如何表示多值动态属性？）为两个对象之间的每个链接创建一个关系对象。 给关系对象一个类型对象来表示关系的含义。（类型对象是多值属性的名称。）类型化关系的优势在于它能够与双向关系良好地协作它提供了一个简单的点来添加关系的属性。 （后者当然是一个单独属性的功能）。您可以为此模式添加复杂的知识级别，沿着与键入的动态属性大致相同的路线。不过你应该考虑一下界面影响。类型化的关系迫使用户意识到雇佣对象，因为确实使用单独的属性。事实上，人们倾向于将财产对象看作是一个完全成熟的对象，而不是一个人（或公司）的一些财产。但合格的关联通常可以为许多目的提供更简单的接口。所以每当你看，或者你正在考虑使用，一种类型的关系;你也应该考虑一下合格的协会形式。您可以在任一方向或两个方向使用它，也可以使用它除了类型化的关系，或者除此之外。但是这两种模式并不完全相同。如果你使用图9，你正在指出一个雇主只能是某一特定工种的雇主。图8没有这样的尽管大多数建模者会暗示这样的约束，除非工作有附加属性。当然，就业往往是有的附加属性。一个常见的例子是日期范围（如问责制[Fowler，AP2.4节。图9.使用与图8相同情况的合格关联123public Personpublic void addEmployer (Company company, EmploymentType type);public Enumeration getEmployersOfType (EmploymentType type);列举17, 图9的接口图10.键入的关系，显示通常假定的约束不同种类的人到目前为止，我们假设我们只有一种人，并且我们定义了一个属性人是所有人的有效财产。但是，你确实有你的情况不同类型，不同类型的属性。经理可能需要一个财产部门管理，执行可能需要一个财产的行政洗手间的关键号码（在一个不是90年代的公司）。别担心，我听到“使用继承愚蠢”的呼声。事实上，这是其中的一种情况这通常用于子类型。其实它比这个更涉及，特别是当你开始思考一个人可能扮演的角色。我已经写了一整篇文章模仿角色[福勒角色]的主题。角色模式考虑我们的情况对操作的变化和固定属性的变化感兴趣。但在这种情况下，我要探索不同类型的对象与动态属性的概念的重叠。这种重叠产生了动态属性知识水平模式（一个名字越来越少我的口味太大）。为了使用这个模式，我们给Person一个Person类型的类型对象。那我们可以这样说人员类型与联系人类型的关联指示哪些人员可用的属性谁有那个人类型如果我们试图使用，或要求，在一个人的财产人类型可以用来检查使用是否正确。图11.动态财产知识水平1234567class Person &#123;public Object getValueOf(ContactProperty key);public boolean hasProperty(ContactProperty key);public void setValueOf(ContactProperty key, Object newValue);class PersonType &#123;public boolean hasProperty(ContactProperty key);public Enumeration getProperties();列举18, 图11的操作12345class Person &#123;public Object getValueOf (ContactProperty key) &#123;if (!hasProperty(key))throw IllegalArgumentException(“Innapropriate key”);//return the value列举19, 检查具有动态属性知识级别的适当的密钥当我们开始使用这样的知识水平时，单独的财产变得越来越多重要。在这种情况下，我们很快就会开始停止将其视为一种财产，而不是某种客体在自己的权利。什么是财产和什么不是非常模糊的界限，这实际上取决于你对事物的看法。123动态财产知识水平你如何执行某些类型的对象具有某些特性使用动态属性？创建一个知识级别来包含什么类型的对象使用的规则哪些类型的属性动态属性的几个小结各种各样的动态属性构成了本文的大部分内容。但我必须重申那动态属性是我想要尽可能避免的。动态特性带来了沉重的负担：接口不够清晰，使用困难操作而不是存储的数据。只是有时候你别无选择，只能用他们在这种情况下，这个文件应该有用的给你一些替代品和之间的权衡。动态属性出现在改变界面有困难的地方。人谁与分布式对象系统一样工作，至少在原则上，因为它允许他们可以在不损害客户的情况下改变界面-而在分布式系统中则可能很难找到你的客户。但是你仍然应该警惕这样做。任何当你为你有效改变的动态属性添加一个新的密钥界面。所有的动态属性都在替换运行时检查的编译时间检查。你仍然有同样的问题保持你的客户最新。动态属性的另一个常见用途是在数据库中。这不仅仅是因为这个接口问题，而且由于数据迁移的问题（如果不是主要的话）。改变一个数据库模式不仅会对使用该模式的程序造成潜在的变化，可能会迫使你做一个复杂的数据转换练习。动态属性也是允许的你可以在不改变数据库模式的情况下改变一些东西，从而不需要做任何事情数据转换。在大型数据库中，这可能是一个引人注目的优势。你不知道的属性我想在本文中添加一个最后一个重要的属性。情况就是如此具有财产的物体没有意识到。当财产被隐含时，会发生这种情况另一个对象和它与你有关的方式。考虑一个管理数据库连接的对象。它创建了一堆数据库连接并在请求时将它们交给其他对象。当一个客户端完成这个连接可以将它返回给管理员，以供其他人使用。你可以做这通过向连接添加一个isBusy属性。图12显示了使用一个替代方案外在财产。连接是空闲的还是繁忙的，取决于收集的内容它所在的连接管理器。如果你有一个连接，你不能问它是否是自由或忙碌，相反，你将不得不问连接管理器是否一个特定的连接空闲或忙碌。你可以这样说，因为组合关联是一种方式。连接不知道连接管理器。在某种意义上说是忙/闲状态根本不是一个连接的属性。但至少从某种意义上说，这就是我提到它的原因。图12.使用外部收集属性在纯粹的概念模型意义上，这种模式没有多大意义。 但是这里有实际的实施原因，你可能想要使用它。 如果你想对此做所有更改财产要经过一个连接管理者，那么这个方法就说明了这一点。在特别是当你想让连接管理员免费给你时，这是一种自然的风格连接，你不关心哪一个。使用外部属性的另一个原因是如果连接类是由某人提供的否则你不能改变它的接口。您可以添加新的属性而不更改连接类。123外在属性你如何给对象一个属性而不改变它的接口？让另一个对象负责知道这个属性。外在性质的一个大问题是它会导致一种尴尬和不自然的现象接口。通常如果你想知道什么，你只需找到合适的对象并询问它。 在这里你需要找到持有外部集合的对象，并询问它适当的对象。在某些情况下，比如这个，似乎是合理的。 但大部分我宁愿让对象了解自己的属性（在这种情况下，我打电话他们的内在属性）。最后的想法当我完成本文时，我觉得需要再次敦促你不要使用我一直在写的东西这里除非你真的需要它。固定属性的好处是伟大的。 如果你需要别的，那么我希望这篇论文给你一些想法和一些指导。但是固定的物业永远是你的第一选择。参考[Fowler, AP] Fowler, Martin. Analysis Patterns: Reusable Object Models, Addison-1997[Fowler, roles] Fowler, Martin. Dealing with Roles,http://www.awl.com/cseng/titles/89542-0/awweb.htm[POSA] Buschman et al, Pattern Oriented Software Architecture, Wiley 1997]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>属性</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP扫描二维码登陆流程]]></title>
    <url>%2F111417%2Fap-scan-two-dimensional-code-landing-proces%2F</url>
    <content type="text"><![CDATA[流程客户端页面请求二维码(带有客户端标识和操作标识),这个二维码实际上来自安全中心的后台生成.(二维码状态:待扫描),此时信息需要放在redis里面保存起来客户端页面获取到二维码之后,轮询客户端后台,查看这个标识的状态.安全中心APP(已登录)扫描客户端前台生成的二维码,然后将识别出来的信息获取后访问安全中心后台,安全中心后台将当前APP用户的唯一标示和当前的二维码信息绑定,回调客户端后台.(二维码状态:已扫描)安全中心APP上操作是否确认,然后改变当前二维码标示(二维码状态:已同意或已拒绝)客户端前台轮询到已扫描可以提示用户确认,轮询到已同意可直接系统自动登录(通过绑定的用户唯一标识获取到用户加密的密码,走正常的登录流程,).成功之后注意清空密码信息.二维码生成工具12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;图片由ProcessOn生成]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>登陆</tag>
        <tag>APP</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo集成gitment异常处理]]></title>
    <url>%2F110917%2Fhexo-integrated-gitment-exception-handling%2F</url>
    <content type="text"><![CDATA[问题集成Gitment按照官方的文档配置报错Cannot read property &#39;firstChild&#39; of null查找通过页面的异常进入js发现是获取某个对象为空gitment-container讲这个关键词在插件里面搜索发现,这个一个装载留言内容的div,于是在异常的页面查看源码搜索,没有找到这个div.通过查看源码发现themes\next\layout\_third-party\comments是一个留言的插件集合,包含多种留言插件js文件12345678&#123;% include 'duoshuo.swig' %&#125;&#123;% include 'disqus.swig' %&#125;&#123;% include 'hypercomments.swig' %&#125;&#123;% include 'youyan.swig' %&#125;&#123;% include 'livere.swig' %&#125;&#123;% include 'changyan.swig' %&#125;&#123;% include 'gitment.swig' %&#125;&#123;% include 'valine.swig' %&#125;themes\next\layout\_partials是留言插件html文件comments.swig有一段代码引起我的注意1234567891011121314&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="SOHUCS"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;对照themes\next\_config.yml文件12345678changyan: enable: false appid: XX appkey: XXgitment: enable: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway mint: false要命的是之前是用畅言测试过,但是这里不是根据changyan.enable去判断,于是导致ifelse进入了畅言这个留言插件的div判断.解决清空themes\next\_config.yml文件中的changyan.appid和changyan.appkey,themes\next\layout\_partials\comments.swig文中,theme.changyan.appid and theme.changyan.appkey修改为theme.changyan.enable总结规范开发善于关键词查找分析解决问题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>gitment</tag>
        <tag>Hexo</tag>
        <tag>规范开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件或主题修改记录]]></title>
    <url>%2F110617%2Fplug-in-or-topic-modification-records%2F</url>
    <content type="text"><![CDATA[短路径利于Seo修改文章默认路径原来是YYYY改为YY文件路径%HEXO_HOME%lib\plugins\filter\post_permalink.js,方法postPermalinkFilter中的meta的year属性.代码块颜色不够显眼修改默认的灰色为红色,文件路径\themes\next\source\css\_variables\base.styl中前几行颜色定义$red变量改为#ff2a2a持续更新中…]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高房价背后的真实逻辑（深度长篇分析）]]></title>
    <url>%2F110517%2Fthe-real-logic-behind-the-high-house-price-(a-long-analysis-of-the-depth)%2F</url>
    <content type="text"><![CDATA[这篇文章不做好和坏的价值判断，只谈现象背后的逻辑和规律。我会向你表达我真实的看法，但文章的结论可能会有点残酷。要不要往下读，取决于你自己。但我相信，尽早看清现实，早做打算，能够帮助你在人生的关键路口做出正确的判断。01马太效应（强者愈强，弱者愈弱）是世间最冰冷的规则，却又无处不在。2015年，公众号“城市数据团”发表了一篇爆文《逃离你终将衰落的家乡》。文章以各省人口流动的大数据（2005年-2010年）为依据，得出了一个残酷的结论：大都市就像抽水机，不停地从落后省份抽取劳动力，或许将来的某一天，我们就会像今天的日本一样，无数村庄和城镇凋零衰败，但东京和大阪都市圈繁华依旧。大都市将毫不留情地吸干周边地区的血液，以便自己能够生存。残酷吗？不，因为这是年轻劳动力自己用脚（投票）投出的结果。（图片来自“城市数据团”）而由人口迁徙引申出来的推论，则更加触目惊心：你还能在这些选择（逃离北上广还是逃回北上广）中犹豫，说明你无比幸福，因为你们的下一代和下下一代可能不会再有任何选择的机会。假如你最终选择留在了一个生活安逸风景如画的小城镇上，你也许会幸福地过完一生；但在你的子女到了你这个年纪的时候，很可能他们有且只有一个选择，那就是——逃离他们终将衰落的家乡。我曾在《社会即将分层，你将会在第几层？》一文中引用了“城市数据团”的分析结论。当时有一些人对结论持怀疑和反对态度，因为他们相信政府调控的力量。政府一边限定了特大城市的常驻人口指标，一边强调要引导中心城市人口向周边转移（如某部委印发了《全国国土规划纲要》）。控制特大城市规模，让各个区域平衡发展是政府调控的目标。那么，现实情况又是怎样？揭开答案前，先来看看日本的情况。日本有三个地方GDP特别高，那就是东京、名古屋和大阪，这三个地方的GDP加起来，占全日本GDP总量的80%以上，所以这三个地方又被称为日本的三大都市圈。根据日本总务省2014年公布的数据，三大都市圈人口总数高达6439.33万人，占日本全国总人口的50.93%，到了2017年，这个数据变成了6453.26万人，人口数占比达到了51.38%。也就是说，哪怕是在人口负增长的国家，人们依然在源源不断地向发达地区聚集。这就是人口的聚集效应。中国聚集效应则更加明显。今年年初，“城市数据团”发布了文章《曾经熟悉的家乡终将成为倍感孤独的地方》。文章根据2014年-2016年春运大数据，再次揭示了这个残酷的事实：相比于2005-2010年期间的数据，最近3年全国人口流动的集聚程度仍然在进一步地提高。大城市的人口抽血能力并没有减缓，反而在持续地加强。更多地方的人们愿意跋涉更远的距离，承担更高的成本，以逃离他们的家乡。（一线城市从全国人口抽血盛况）（准一线城市抽血地图）为什么会这样？有网友给出了这样的答案：人向大城市集中，因为大城市有更多的就业机会，有更好的发展，比如做IT的，就要往北上杭深走；但是，很少有大城市的人走向小城市去，因为小城市有的，大城市基本也有。另外，交通的发展也导致了大城市对小城市人员的吸引，在前些年高铁热的时候，基本所有的地方政府都认为高铁来了，钱就到了，但更多的是，高铁来了，人就走了。具体到我们家来说，县里只有几家大企业，能做的是制造业、商业这些，但这些需要的工人较多，走出去的大学生很少去做这个；另一方面，你在外读书期间习惯了大城市的生活，读书馆、电影院、博物馆、书店、游乐场，县里没有啊。很多人误以为政府的调控是无所不能的，他们错了。社会运行自有其内在规律。人口迁移遵循聚集效应，社会发展遵循马太效应。大都市拥有优质的政治资源、商业资源、教育资源、人力资源……这些优质资源吸引着无数优秀的年轻人，而优秀的年轻人将推动大都市的繁荣发展，从而让大都市获取更多的资源，于是形成了一个优势迭代的良性循环，这就是马太效应中的强者愈强。然而，大都市在攫取优秀人才的同时，也在用高额的房价和户籍制度将千千万万的普通人挤到繁华都市的边缘，将他们赶到逼仄的地下室，脏乱的出租房，直到他们梦碎的那一天，收起行囊，滚回家乡，然后他们的下一代再背起行囊，逃离家乡。这就是马太效应的另一面，弱者愈弱。这听起来非常残酷，却又无比现实。02前几天我发起了关于房价的意见征集，有一位读者给我留言说：我们在北京的时候年收入近50万买不起房子，后果就是举家撤离，再也无法享受北京的生活便利、以及包括医疗和教育在内的各种资源。离开北京一年了，和其他地方相比，感觉北京除了房子贵，其他都是相当便宜的！现在后悔得很，买不起房直接导致我和孩子们命运轨迹的改变！所以，在北京，只要有预估能力，就应该贷款买房！这条留言指出了房子的真正价值。当你买房的时候，买的并不仅仅是一个遮风避雨的居住场所，还包括周边提供的医疗、教育、交通、娱乐、公用服务以及发展机遇。比如说，北大的很多课程都是对外开放的，如果你住在北大边上，你可以免费享受中国最顶尖的教育资源。再拿学区房为例。很多人说，天价学区房是国人的焦虑感和功利性心态造就的，但他们不知道，学区房的概念其实起源于美国。吴军老师在他的专栏写过一篇文章《怎么看名校毕业生在北京买不起学区房》，里面有这样一段介绍：美国好学区的房价和差学区的房价差别比中国要厉害得多，很多时候，隔着一条街，房价可以差几倍。在硅谷中心的帕罗阿图市（Palo Alto虽然叫做城市，但它只有两万人，相当于中国的一个小镇），处于中值水平的独栋房房价在300万美元以上，而和它只隔着一条马路的东帕罗阿图中位数房价只有60-80万美元左右。这两个区的差别有多大呢？一边住着拉里·佩奇、扎克伯格，以及很多斯坦福的教授，过去乔布斯也在那里，另一边是很多中低收入的墨西哥裔居民，包括不少非法移民。在美国，没有人觉得这种划分学区的方法有什么不好，因为大家习惯了。但是久而久之，学区好的地方聚集着比较体面、富有的一些家庭，不好的学区，整个条件都比较差，这是一个事实，而且很长时间几乎没有改变过。万维钢老师在《美国教育各阶层分析》一文中也提到了类似的观点：美国是个有严重阶层区分的国家，各社区按房价自然分开，在某种意义上是事实上的种族和贫富隔离。公立中小学的经费主要由所在学区的房产税而来，这意味着两点：第一，富人区的学校更有钱，可以请更好的老师、用更好的设备、有更高的教学水平；第二，学生们其实是在跟自己同阶层的人一起上学。教育资源不是标注品，必定有高下之分，而优质的教育资源永远是稀缺的。学区房的出现，本质上是一种教育资源的分配方案。当你买下学区房的时候，买的是下一代接受良好教育的入场券。03“房子是用来住的，不是用来炒的。”今年的大会，这句话非常鼓舞人心。但有太多人误解了这句话。其完全的表述是：“坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、租购并举的住房制度，让全体人民住有所居。”什么叫多渠道保障？什么叫租购并举？什么叫让你住有所居？大会只承诺了房子的居住功能，并没有承诺你可以轻易地拥有房屋的产权，更没有承诺你能拥有房子背后的隐性价值。其实早在去年3月的时候，发改委主任就曾提出：现在我国租房比例太低，购和租要并举。政策的大方向是要推广房屋租赁，而不是让你买得起房。是政府不重视民生问题吗？并不是。先来看看国外的情况。根据欧盟统计局2014年的数据，欧盟28国的所有人口中，有近三成(29.9%)的人是租房子住的，其中德国的租房比例达到了47.5%，仅52.5%的人居住在自有住房内。也就是说，将近一半的德国人都是租房的。美国的情况也是类似。根据皮尤研究中心的一项调查显示，2006年，57%的35岁以下家庭是租房子居住的。到了2016年，这个比例已经提高到了65%把年龄放宽一点，35至44岁的美国家庭中，租房的比例依然高达41%。这还只是平均数据，如果把目光聚焦到全球范围内的一线城市，当地人拥有住房的比例更低。比如德国的首都柏林，住房拥有率只有15.6%，有将近85%的人都只能租房子住。（图片来自公众号“财经连环话”）再来看看我们的春运人口迁移图你就会明白：中国的人口基数太大了，但大城市的土地资源是有限的。在有限的土地上，怎么可能满足所有人在大城市买房的需求？唯有加快推广租赁。从这一点来讲，租售并举的政策大方向是没错的。但连带提出的“租售同权”则纯粹是在画大饼了。04今年7月，一篇名为《突发，楼市巨变！广州宣布：租售同权》的文章突然刷屏了，原因是广州出台了《关于印发广州市加快发展住房租赁市场工作方案的通知》，通知里有这么一句话：“赋予符合条件的承租人子女享有就近入学等公共服务权益，保障租购同权。”于是那篇爆文的作者这样解读道：从今天开始，中国的买房终于和教育资源脱钩了，没有房，小孩照样可以上学了。这绝对是一次历史创举，具体未来的影响可能远超我们的想象，但绝对是我们现在无法估量的。但就像我在前面说了，学区房的本质是一种教育资源的分配方案。在教育资源没有变多，而大城市人口还在不断聚集的情况下，“租售同权”完全是个伪概念。当适龄的报名儿童超过学校招生计划时，学校会怎么做？杭州就有关于“一表生”、“二表生”的录取规则。即学校应该根据学龄儿童户籍和家庭住宅情况，按照“住、户一致”优先原则，按下面四种先后顺序录取：05楼市有泡沫吗？有啊，但不在一线城市，而是在三四五六线城市。2016年和2017年经历了两波房价的暴涨，但这两波的性质是不同的。2016年的那波暴涨，是因为实业资本转移到了一二线城市的楼市，推高了房价，随后炒房团涌入，再次推高房价，但钱都是流向大城市的。但2017年这一波就不一样了。因为2016年的这波暴涨，政府开始调控了。42个大城市（截止9月23日）先后出台了限售、限购等政策，炒房团买不了房了，于是纷纷涌向了三四线城市。但是，在三四线城市：有优质的教育资源吗？有优质的医疗服务吗？有丰富的娱乐场所吗？有良好的公共服务吗？有广阔的发展机遇吗？都没有。这不过是一场击鼓传花的游戏。最后接盘的那些投机客，他们将会为自己炒高房价的行为付出代价。06经济学家马光远提出过楼市的后视镜原理：从房价的基本规律看，在一个国家城市的人口净增加，一个国家的人口转折点没有到来，以及一个国家的人均GDP尚未超越中等收入水平的情况下，资产价格长期的趋势仍然是向上的，无一例外。今天看到的资产价格的高点，明天很可能只是半山腰而已。回顾过去20年中国房价，站在当时的时空下，每年都觉得房价很高，但回过头看，那些以前认为高不可攀的价格，现在看起来是不是很便宜？这就是房价的“后视镜”原理。只要中国的经济持续向前发展，大城市的房子就依然会升值。这里的大城市，是指四个一线城市及杭州、南京、苏州等几个重点二线城市。这些大城市的房价中，包含了教育、医疗、交通、娱乐、公共服务、发展机遇等隐性价值，正是这些隐性价值支撑着其高昂的房价。要记住一点：优质的资源永远是稀缺的，稀缺的资源永远是昂贵的。土地的总量是有限的，而想要定居大城市的人是源源不断的。大城市好地段的房子是有形且有限的资源，买房的本质就是占有资源。还要记住的一点是：财富是以家庭为单位的。我以前写过这么一段话：年轻人可以不靠父母在大城市买房吗？对于70后而言，这样的想法叫志气；对于80后而言，想要实现靠机遇；对于90后而言，如果还抱着这样的想法，只能说是学生气。如果你的家庭有足够的实力，我强烈建议你们尽早在一线城市买房。如果负担太大，也可以退而求其次，在重点二线城市买。中国未来的房价地图也会围绕三大都市圈和个别的交通枢纽城市展开。或许短期内房价会波动，但从长期看，依然会升值。这是我的判断，并且我对自己的判断很有信心。如果你的家庭无法支撑起你在一二线城市买房，你也可以有两种选择：在大城市租房打拼，我知道这样会很辛苦，但多少会给你带来改一点变命运的机会。回到你的家乡，那里有你童年的记忆和年迈的父母亲戚，但可能没有你孩子的未来（原因见人口的流动）。（有网友说，这就像一群没核的红细胞从肢体末端蜂拥至心脏）这两个选择没有对错，但每种选择都有其代价，而人生，则是一个又一个选择叠加起来的总和。十年后你所站立的地方，你下一代所站立的起点，都是你今天的选择所带来的结果。P.s关于房价，其实还有很多因素可以讲，比如土地供应、货币超发等等，但这些都不是决定性因素，而且这篇文章已经快6000字了，就不再多说了。关于中国的三大都市圈和个别的交通枢纽城市，我会另写一篇。再P.s**总有人问，为什么每次越调控房价涨得越快。其实他们是把因果关系搞反了。并不是因为调控导致房价上涨，而是房价本来就要往上涨，但政府通过各种手段（限价、限售等）强行暂停了房价的上涨。所以一旦调控放开之后，房价立即就会补涨。**对于房价的管制，北大的薛兆丰老师有一个比喻：你仅仅按住价格，并不能改变价格背后的现实。这好比你管不住温度，却非要去管温度计一样荒唐。再再P.s《魔鬼经济学》中有一句话我印象非常深刻：“如果说伦理道德代表了我们心目中理想的社会运行模式的话，那么经济学就是在向我们描述这个社会到底是如何运行的。”很多时候，我们乐于相信生活应该是什么样子的，但沉溺在自己的理想世界并不能解决任何问题，看清现实，早做打算，才是对自己的人生负责。这篇文章虽然一点也不温暖，甚至有点冷漠，但我相信看完后它会对你有所帮助。转载自 雪球 资本x时代]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>生活</tag>
        <tag>房子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制位运算实例]]></title>
    <url>%2F103117%2Fbinary-bit-operation-example%2F</url>
    <content type="text"><![CDATA[二进制位运算实例问题设计多选题的选项问题,一道题有多个选项ABCD,可能有更多如何设计更有效存储识别?分析选项只有选与不选的区别,而且总的个数固定,而且判定2个结果是否存在(答案是否正确),二进制完全满足条件.结果单个选项12345A：1 1B: 1 &lt;&lt; 1 2C: 1 &lt;&lt; 2 4D: 1 &lt;&lt; 3 8...组合选项123AB： 1|2BC: 2|4ABCD: 1|2|4|8比较答案正确答案 ABC : 1|2|4 --&gt; 7用户选择 AB : 1|2 --&gt; 3运算 3!=7 &amp;&amp; 3|7=7 说明部分答对用户选择 BD : 2|8 --&gt; 10运算 10!=7 &amp;&amp; 10|7=!7 说明有错误选项相关知识Java位运算(移位、位与、或、异或、非）]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InvalidClassException]]></title>
    <url>%2F103117%2Finvalidclasexception%2F</url>
    <content type="text"><![CDATA[InvalidClassException背景项目使用的SpringBoot架构,使用的是默认的Redis存储登陆信息过程添加了一个有关于UsUser的接口,需要把当前登录信息返回给前端。结果访问时InvalidClassException异常12org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.InvalidClassException: com.usc.core.model.UsUser; local class incompatible: stream classdesc serialVersionUID = -4391106051528831723, local class serialVersionUID = -3047559744731102659 at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:82)思考&amp;总结看到这个的第一反应是有人修改了serialVersionUID,然后发现这个类并没有这个字段.然后联想到这个信息是从redis获取的然后清理了redis中的登陆信息,异常不再出现.最后注意到这个org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize,已证明联想正确,出现问题到解决5分钟不到.相关知识serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-config client不能连接server]]></title>
    <url>%2F103017%2Fspringcloud-config-client-canot-conect-to-server%2F</url>
    <content type="text"><![CDATA[错误详情config clientjava代码1new SpringApplicationBuilder(Application.class).properties("spring.cloud.config.enabled:true").web(true).run(args);yml配置123456789spring: application: name: masque cloud: config: uri: http://localhost:8888 profile: dev label: final enabled: true依赖12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;出现的问题官方示例中不需要配置 spring.cloud.config.enabled默认是true现在的情况是必须配置这两个enabled,否则client不会去找server 项目正常启动,没有任何异常解决办法在对照了所有的java代码,翻阅了网上的一些博客发现,client多了一个依赖spring-cloud-config-server 去掉这个就正常了]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员]]></title>
    <url>%2F102217%2Fprogramer%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;公司最值钱的东西是产品，如果要问比产品更有价值的是什么？我认为是实实在在做事情的程序员们。&ensp;&ensp;&ensp;&ensp;他们虽然工资不高，每天坐在位置上敲着代码，在很多人眼中被称为“屌丝”或“宅男”，但我认为恰恰就是这些人，他们才是公司最有价值的人。&ensp;&ensp;&ensp;&ensp;他们有自己的理想，希望能够通过自己的努力，从中得到那一点点所谓的成就感。他们需要理解产品经理真正的意图，把想法变成现实，让产品真正落地。他们更容易把握细节，而这些细节往往决定着产品的命运与成败。他们突如其来的跳槽，对我们的项目的交付有直接的影响。他们在一起工作的气氛，能体现技术公司的文化与底蕴。由此看来，对程序员的重视是相当有必要的，我们需要关心每一位程序员的职业发展，让他们在团队里能够充分地发挥出自己的能力。&ensp;&ensp;&ensp;&ensp;我们也需要对他们倍加关注，挖掘出有能力、肯吃苦、敢担当的人，给他们更多的机会，让他们成为技术领袖。&ensp;&ensp;&ensp;&ensp;互联网技术公司需要大量这样的程序员：他们是一群有着技术信仰的人，他们是一群热爱编程的人，他们是一群不解决问题睡不好觉的人。他们不是打杂的，不是外包，更不是工具。他们不喜欢被忽悠，不喜欢被冷落，更不喜欢被驱动。他们需要尊重，需要培养，更需要激情！转载自 开源社区 黄勇的博客]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
