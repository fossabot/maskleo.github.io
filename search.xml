<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[错误的使用了时间戳]]></title>
    <url>%2F012718%2Fwrong-timestamp-used%2F</url>
    <content type="text"><![CDATA[症状如下： 用户上传的证件日期确定填写的2015-02-24，我们在后台查询了日志和数据库确定是这个值。 在用户员管理审核时显示2015-02-23 我们本地无法重现这个问题，显示的是2015-02-24 过程 管理员身在泰国曼谷（东七区）与我们不在一个时间区（东八区），于是我们将本地的时间调整为东七区，问题重现了。 发现日期是后端传递的时间戳，到前端调试下发现，时间戳转换成日期是2015-02-23 23:00 00,格式化只取日期就是显示的2015-02-23 解决 传递时间字符串 其他关联 需要国际化的系统设计 header传递lang语言标示 后端返回提示需要配置多语言，采用统一错误编码匹配。]]></content>
      <categories>
        <category>QA</category>
      </categories>
      <tags>
        <tag>timestamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖动排序后台逻辑思考过程]]></title>
    <url>%2F012718%2Fdrag-order-thinking%2F</url>
    <content type="text"><![CDATA[需求实现类似这个的排序后台逻辑 思考 必要字段主键id，sequence 前端传递最后的值直接保存? 如果这个不是管理员使用的话，可能被注入错乱的相同排序序号，就无法正确的排序了。 时间比较紧急，前端需要去查找插件的使用方法等。 通常前端是实现页面效果和简单的控制，复杂的逻辑还是后端实现。 排序逻辑思考 最简单的情况 初始值如下 12345id - sequenceA - 1B - 2C - 3D - 4 现在将D-4和C-3调换位置 12345id - sequenceA - 1B - 2D - 4C - 3 想要保存这个结果必须修正C和D的sequence 结果如下 12345id - sequenceA - 1B - 2D - 3C - 4 那么这个过程中只是调换了C和D的sequence 最复杂的情况如下初始值如下 12345id - sequenceA - 1B - 2C - 3D - 4 现在将D-4拖动到顶层 12345id - sequenceD - 4A - 1B - 2C - 3 想要保存这个结果必须修正所有的sequence结果如下 12345id - sequenceD - 1A - 2B - 3C - 4 小结：这个排序其实就是把sequence重新分配，只要将所有的sequence重新排序，然后按照顺序分配即可。 解决方案 前端传递id数据库自关联修改 sequence 问题：数据库不会简单的根据传递的参数来排序 传递参数 D,A,B,C 期望: 12345id - sequenceD - 4A - 1B - 2C - 3 实际情况： 12345id - sequenceA - 1B - 2C - 3D - 4 通过查询查询资料这个需要写复杂的函数来解决，sql中不宜写复杂的函数，难以维护。 在java中排序然后批量更新(逐条更新会有并发问题的可能性)。 123456789101112131415161718public BaseResp&lt;Void&gt; sort(List&lt;DocumentSort&gt; sortList) &#123; List&lt;Integer&gt; sequenceList = new ArrayList&lt;&gt;(sortList.size()); sortList.forEach(d -&gt; sequenceList.add(d.getSequence())); Collections.sort(sequenceList); List&lt;DocumentCatalog&gt; needUpdate = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; sortList.size(); i++) &#123; DocumentSort document = sortList.get(i); if(Objects.equals(document.getSequence(), sequenceList.get(i)))&#123; continue; &#125; DocumentCatalog catalog = new DocumentCatalog(); catalog.setId(document.getId()); catalog.setSequence(sequenceList.get(i)); needUpdate.add(catalog); &#125; if(0 != needUpdate.size()) &#123; documentCatalogMapper.batchUpdate(needUpdate);&#125; 通过测试这段代码还是存在问题： 当前端拖动的速度过快，数据sequence重复了！！！ java并发问题? 这个方法没有共享变量 Collections.sort(sequenceList)调用的是自身的排序，排查并发问题 这个是批量更新 核查了前端传递的数据，不存在传递相同的sequence 偶然发生debug不合适 详细日志，重现问题 初始值12345id - sequence db-sequenceA - 1 1B - 2 2C - 3 3D - 4 4 2. 将`D`移至第一个 12345678id - sequence db-sequenceD - 1 1A - 2 2B - 3 3C - 4 4``` 3. 将`A`和`B`调换 此时前端传递的`sequence`没变 id - sequence db-sequence D - 4 1 B - 2 3 A - 1 2 C - 3 4 124. 重排后结果： id - sequence db-sequence D - 1 1 B - 2 3 A - 3 2 C - 4 4 1235. 增量更新就不会更新`B`的`sequence`最后结果数据库 id - sequence db-sequence D - 1 1 B - 2 3 A - 3 3 C - 4 4 ``` 6. 此时出现了2个`3` 最终代码全量更新得到正确结果： public BaseResp&lt;Void&gt; sort(List&lt;DocumentSort&gt; sortList) { List&lt;Integer&gt; sequenceList = new ArrayList&lt;&gt;(sortList.size()); sortList.forEach(d -&gt; sequenceList.add(d.getSequence())); Collections.sort(sequenceList); List&lt;DocumentCatalog&gt; needUpdate = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; sortList.size(); i++) { DocumentSort document = sortList.get(i); DocumentCatalog catalog = new DocumentCatalog(); catalog.setId(document.getId()); catalog.setSequence(sequenceList.get(i)); needUpdate.add(catalog); } if(0 != needUpdate.size()) { documentCatalogMapper.batchUpdate(needUpdate); }]]></content>
      <categories>
        <category>QA</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RedisTemplate能注入到ValueOperations对象的疑问解惑]]></title>
    <url>%2F010418%2Fwhy-ValueOperations-can-inject-RedisTemplate%2F</url>
    <content type="text"><![CDATA[疑问在刚开始接触redis的时候发现项目有这样一段看起来有问题的代码1234@Resource(name = "redisTemplate")public void setValOps(ValueOperations&lt;Object, Object&gt; valOps) &#123; CacheUtils.valOps = valOps;&#125; 对，这个是注入代码，我们所知道的注入必须类型匹配，于是我翻看了RedisTemplate的源码extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAwareRedisAccessor implements InitializingBeanBeanClassLoaderAware extends Aware而让我感到惊奇的是这些类和接口和 RedisOperations 没有任何的关联?启动和使用过程都没有任何问题，这个是怎么回事呢？ 发现通过查询资料发现ValueOperationsEditor这个类,注释PropertyEditor allowing for easy injection of {@link ValueOperations} from {@link RedisOperations}. 很明显就是这个类讲两个没有任何关联的类能够注入绑定。 代码如下:123456789class ValueOperationsEditor extends PropertyEditorSupport &#123; public void setValue(Object value) &#123; if (value instanceof RedisOperations) &#123; super.setValue(((RedisOperations) value).opsForValue()); &#125; else &#123; throw new java.lang.IllegalArgumentException("Editor supports only conversion of type " + RedisOperations.class); &#125; &#125;&#125; RedisTemplate实现了RedisOperations接口,这段代码意思就是调用RedisTemplate的opsForValue()方法来给ValueOperations注入,事实上这个方法返回类型就是ValueOperations.即回答了我们的疑问. 答疑PropertyEditorSupport这个核心的类提供了基类支持,就像注释写的一样 这是一个帮助建立属性编辑器的支持类。它既可以用作基类，也可以用作委托。 扩展Resource来看看Resource注解,搜索下有哪些地方使用了这个注解 看到了我们熟悉的spring包 很明显的是表示注解字段或setter方法注入信息的类，支持@Resource注释。 Autowired相关核心类AutowiredAnnotationBeanPostProcessor 从代码的注释到方法命名字段命名都值得学习。 小窍门idea的Find Usages功能(右键)非常强大 不仅有注解还有字段、类、注释、引用。]]></content>
      <categories>
        <category>QA</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>Resource</tag>
        <tag>Autowired</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[builder]]></title>
    <url>%2F120917%2Fbuilder%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/07_builder 意图分离复杂的对象从它的结构代表性，使相同的施工过程可以创造不同的表示。 说明真实世界的例子 想象一下角色扮演游戏的角色生成器。最简单的选择是让电脑为你创造角色。但是如果你想选择职业，性别，发色等字符细节，字符的生成就成了一个循序渐进的过程，当所有的选择都准备好的时候就完成了。 用简单的话来说 允许您创建不同的对象风格，同时避免构造器污染。当可能有几种风格的对象时很有用。或者当创建对象时涉及很多步骤。 维基百科说 构建器模式是一种对象创建软件设计模式，旨在寻找伸缩构造器反模式的解决方案。 话虽如此，让我加一些关于什么伸缩构造反模式。在某一点或其他我们都看到了如下构造函数：12public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) &#123;&#125; 正如你所看到的，构造函数参数的数量可能会很快失去控制，并且可能很难理解参数的排列。 再加上这个参数列表可以继续增长，如果你想在将来添加更多的选项。 这被称为伸缩构造反模式。 编程示例 理智的选择是使用Builder模式。 首先我们有我们想要创造的英雄 1234567891011121314151617public final class Hero &#123; private final Profession profession; private final String name; private final HairType hairType; private final HairColor hairColor; private final Armor armor; private final Weapon weapon; private Hero(Builder builder) &#123; this.profession = builder.profession; this.name = builder.name; this.hairColor = builder.hairColor; this.hairType = builder.hairType; this.weapon = builder.weapon; this.armor = builder.armor; &#125;&#125; 然后我们有建设者 12345678910111213141516171819202122232425262728293031323334353637383940public static class Builder &#123; private final Profession profession; private final String name; private HairType hairType; private HairColor hairColor; private Armor armor; private Weapon weapon; public Builder(Profession profession, String name) &#123; if (profession == null || name == null) &#123; throw new IllegalArgumentException("profession and name can not be null"); &#125; this.profession = profession; this.name = name; &#125; public Builder withHairType(HairType hairType) &#123; this.hairType = hairType; return this; &#125; public Builder withHairColor(HairColor hairColor) &#123; this.hairColor = hairColor; return this; &#125; public Builder withArmor(Armor armor) &#123; this.armor = armor; return this; &#125; public Builder withWeapon(Weapon weapon) &#123; this.weapon = weapon; return this; &#125; public Hero build() &#123; return new Hero(this); &#125;&#125; 然后它可以用作： 1Hero mage = new Hero.Builder(Profession.MAGE, "Riobard").withHairColor(HairColor.BLACK).withWeapon(Weapon.DAGGER).build(); 适用性使用Builder模式时 创建复杂对象的算法应该独立于组成对象的部分以及如何组装 施工过程必须允许对构建的对象进行不同的表示 示例 java.lang.StringBuilder java.nio.ByteBuffer as well as similar buffers such as FloatBuffer, IntBuffer and so on. java.lang.StringBuffer All implementations of java.lang.Appendable Apache Camel builders 参考 Design Patterns: Elements of Reusable Object-Oriented Software Effective Java (2nd Edition)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bridge]]></title>
    <url>%2F120917%2Fbridge%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/06_bridge 也被称为手柄/身体 意图将一个抽象与其实现分离开来，以使两者可以独立地变化。 说明真实世界的例子 考虑你有一个不同的附魔武器，你应该允许混合不同的武器和不同的附魔。你会怎么做？为每个附魔创建每个武器的多个副本，或者你会创建单独的附魔，并根据需要将其设置为武器？桥梁模式可以让你做第二个。 用普通话说 桥梁模式是关于比继承更喜欢构图。实现细节从一个层次结构推送到另一个具有单独层次结构的对象。 维基百科说 桥梁模式是软件工程中使用的一种设计模式，旨在“将抽象与其实现分离开，以便二者可以独立地变化” 编程示例 从上面翻译我们的武器示例。这里我们有Weapon层次结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface Weapon &#123; void wield(); void swing(); void unwield(); Enchantment getEnchantment();&#125;public class Sword implements Weapon &#123; private final Enchantment enchantment; public Sword(Enchantment enchantment) &#123; this.enchantment = enchantment; &#125; @Override public void wield() &#123; LOGGER.info("The sword is wielded."); enchantment.onActivate(); &#125; @Override public void swing() &#123; LOGGER.info("The sword is swinged."); enchantment.apply(); &#125; @Override public void unwield() &#123; LOGGER.info("The sword is unwielded."); enchantment.onDeactivate(); &#125; @Override public Enchantment getEnchantment() &#123; return enchantment; &#125;&#125;public class Hammer implements Weapon &#123; private final Enchantment enchantment; public Hammer(Enchantment enchantment) &#123; this.enchantment = enchantment; &#125; @Override public void wield() &#123; LOGGER.info("The hammer is wielded."); enchantment.onActivate(); &#125; @Override public void swing() &#123; LOGGER.info("The hammer is swinged."); enchantment.apply(); &#125; @Override public void unwield() &#123; LOGGER.info("The hammer is unwielded."); enchantment.onDeactivate(); &#125; @Override public Enchantment getEnchantment() &#123; return enchantment; &#125;&#125; 和单独的结界层次 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Enchantment &#123; void onActivate(); void apply(); void onDeactivate();&#125;public class FlyingEnchantment implements Enchantment &#123; @Override public void onActivate() &#123; LOGGER.info("The item begins to glow faintly."); &#125; @Override public void apply() &#123; LOGGER.info("The item flies and strikes the enemies finally returning to owner's hand."); &#125; @Override public void onDeactivate() &#123; LOGGER.info("The item's glow fades."); &#125;&#125;public class SoulEatingEnchantment implements Enchantment &#123; @Override public void onActivate() &#123; LOGGER.info("The item spreads bloodlust."); &#125; @Override public void apply() &#123; LOGGER.info("The item eats the soul of enemies."); &#125; @Override public void onDeactivate() &#123; LOGGER.info("Bloodlust slowly disappears."); &#125;&#125; 而且这两个行动层次 123456789101112131415161718192021Sword enchantedSword = new Sword(new SoulEatingEnchantment());enchantedSword.wield();enchantedSword.swing();enchantedSword.unwield();// The sword is wielded.// The item spreads bloodlust.// The sword is swinged.// The item eats the soul of enemies.// The sword is unwielded.// Bloodlust slowly disappears.Hammer hammer = new Hammer(new FlyingEnchantment());hammer.wield();hammer.swing();hammer.unwield();// The hammer is wielded.// The item begins to glow faintly.// The hammer is swinged.// The item flies and strikes the enemies finally returning to owner's hand.// The hammer is unwielded.// The item's glow fades. 适用性使用桥梁模式时 您想避免抽象与其实现之间的永久绑定。例如，当实现必须在运行时被选择或切换时，情况可能如此。 抽象和它们的实现都应该通过子类来扩展。在这种情况下，Bridge模式可以让您将不同的抽象和实现组合起来，并将其独立扩展 抽象的实施变化不应该对客户产生影响;也就是说，他们的代码不应该被重新编译。 你有一个类扩散。这样的类层次结构表示需要将对象分成两部分。 Rumbaugh使用术语“嵌套概括”来指代这样的类层次结构 您想要在多个对象之间共享一个实现（可能使用引用计数），这个事实应该隐藏在客户端。一个简单的例子是Coplien的String类，其中多个对象可以共享相同的字符串表示。 参考 Design Patterns: Elements of Reusable Object-Oriented Software]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[balking]]></title>
    <url>%2F120917%2Fbalking%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/05_balking 意图Balking Pattern用于防止对象执行某些代码，如果它是不完整或不适当的状态 适用性使用Balking模式 只有在某个对象处于某个特定状态时才想调用这个对象 对象通常只处于暂时喘息的状态，但时间不确定 相关模式 防护悬挂模式 双重锁定锁定模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>初级难度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async Method Invocation]]></title>
    <url>%2F120717%2Fasync-method-invocation%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/04_async-method-invocation 意图异步方法调用是在等待任务结果时调用线程未被阻塞的模式。该模式提供多个独立任务的并行处理，并通过回调检索结果，或等待一切完成。 适用性使用异步方法调用模式时 您有多个可以并行运行的独立任务 您需要改善一组连续任务的性能 您的处理能力或长时间运行的任务数量有限，主任务不应该等待所有的任务完成 示例 FutureTask, CompletableFuture and ExecutorService (Java) Task-based Asynchronous Pattern (.NET)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成二维码]]></title>
    <url>%2F120717%2Fjava-generate-qr-code%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.awt.Color;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Hashtable;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.BinaryBitmap;import com.google.zxing.EncodeHintType;import com.google.zxing.LuminanceSource;import com.google.zxing.ReaderException;import com.google.zxing.Result;import com.google.zxing.WriterException;import com.google.zxing.client.j2se.BufferedImageLuminanceSource;import com.google.zxing.common.BitMatrix;import com.google.zxing.common.HybridBinarizer;import com.google.zxing.qrcode.QRCodeReader;import com.google.zxing.qrcode.QRCodeWriter;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;/** * 二维码生成和读的工具类 */public class QrCodeCreateUtil &#123; /** * 生成包含字符串信息的二维码图片 * * @param outputStream 文件输出流路径 * @param content 二维码携带信息 * @param qrCodeSize 二维码图片大小 * @param imageFormat 二维码的格式 * @throws WriterException * @throws IOException */ public static boolean createQrCode(OutputStream outputStream, String content, int qrCodeSize, String imageFormat) throws WriterException, IOException &#123; //设置二维码纠错级别ＭＡＰ Hashtable&lt;EncodeHintType, ErrorCorrectionLevel&gt; hintMap = new Hashtable&lt;EncodeHintType, ErrorCorrectionLevel&gt;(); hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L); // 矫错级别 QRCodeWriter qrCodeWriter = new QRCodeWriter(); //创建比特矩阵(位矩阵)的QR码编码的字符串 BitMatrix byteMatrix = qrCodeWriter.encode(content, BarcodeFormat.QR_CODE, qrCodeSize, qrCodeSize, hintMap); // 使BufferedImage勾画QRCode (matrixWidth 是行二维码像素点) int matrixWidth = byteMatrix.getWidth(); BufferedImage image = new BufferedImage(matrixWidth - 200, matrixWidth - 200, BufferedImage.TYPE_INT_RGB); image.createGraphics(); Graphics2D graphics = (Graphics2D) image.getGraphics(); graphics.setColor(Color.WHITE); graphics.fillRect(0, 0, matrixWidth, matrixWidth); // 使用比特矩阵画并保存图像 graphics.setColor(Color.BLACK); for (int i = 0; i &lt; matrixWidth; i++) &#123; for (int j = 0; j &lt; matrixWidth; j++) &#123; if (byteMatrix.get(i, j)) &#123; graphics.fillRect(i - 100, j - 100, 1, 1); &#125; &#125; &#125; return ImageIO.write(image, imageFormat, outputStream); &#125; /** * 读二维码并输出携带的信息 */ public static void readQrCode(InputStream inputStream) throws IOException &#123; //从输入流中获取字符串信息 BufferedImage image = ImageIO.read(inputStream); //将图像转换为二进制位图源 LuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); QRCodeReader reader = new QRCodeReader(); Result result = null; try &#123; result = reader.decode(bitmap); &#125; catch (ReaderException e) &#123; e.printStackTrace(); &#125; System.out.println(result.getText()); &#125; /** * 测试代码 * * @throws WriterException */ public static void main(String[] args) throws IOException, WriterException &#123; createQrCode(new FileOutputStream(new File("d:\\qrcode.jpg")), "http://dmrs.me", 900, "JPEG"); readQrCode(new FileInputStream(new File("d:\\qrcode.jpg"))); &#125;&#125; 12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Gists</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[website]]></title>
    <url>%2F120617%2Fwebsite%2F</url>
    <content type="text"><![CDATA[python自动上色 google翻译 自动部署 自动部署帮助文档 (http://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/) 阿里图标库 (http://588ku.com) (http://www.iconpng.com) 小图标 进度条&amp;勋章 图标生成 在线编辑 go语言学习 tour]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ali-api-util]]></title>
    <url>%2F120617%2Fali-api-util%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Component@NotThreadSafepublic class AliApiClientUtil implements InitializingBean &#123; @Value("$&#123;aliapi.appKey:no_config&#125;") private String appKey; @Value("$&#123;aliapi.appSecret:no_config&#125;") private String appSecret; @Value("$&#123;aliapi.enable:false&#125;") private boolean enable; private AliApiClient asyncClient; @Override public void afterPropertiesSet() throws Exception &#123; if (enable &amp;&amp; (Constant.DEF_CONFIG.equals(appKey) || Constant.DEF_CONFIG.equals(appSecret))) &#123; throw new RuntimeException(String.format("阿里云第三方API初始化,缺失参数appKey:&#123;0&#125;,appSecret&#123;1&#125;", new Object[]&#123;appKey, appSecret&#125;)); &#125; asyncClient = AliApiClient.newBuilder() .appKey(appKey) .appSecret(appSecret) .build(); &#125; public static class Builder extends BaseApiClientBuilder&lt;Builder, AliApiClient&gt; &#123; @Override protected AliApiClient build(BuilderParams params) &#123; return new AliApiClient(params); &#125; &#125; public static class AliApiClient extends BaseApiClient &#123; private AliApiClient(BuilderParams builderParams) &#123; super(builderParams); &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static AliApiClient getInstance() &#123; return getApiClassInstance(AliApiClient.class); &#125; public void asyncInvoke0(ApiRequest apiRequest, ApiCallBack callBack) &#123; asyncInvoke(apiRequest, callBack); &#125; public ApiResponse syncInvoke0(ApiRequest apiRequest) &#123; return syncInvoke(apiRequest); &#125; &#125; /** *&#123; *"resp":&#123; * "code":0, * "desc":"OK" * &#125; , * "data":&#123;&#125;, * &#125; * 银行卡二、三、四元素实名认证 * https://market.aliyun.com/products/57000002/cmapi014429.html?spm=5176.2020520132.101.5.2lTTNI#sku=yuncode842900008 * @see AliHttpStatusEm * @see com.dotnar.usc.common.util.aliapi.bankcardverifi.BankCardVerifiStatusEm * @param bankCardVerifiVo * @return */ public ApiResponse syncBankCardVerifi(BankCardVerifiVo bankCardVerifiVo) &#123; ApiRequest apiRequest = new ApiRequest(Scheme.HTTP, Method.GET, Constant.BANK_CARD_VERIFI_HOST, Constant.BANK_CARD_VERIFI_API_PATH); apiRequest.addParam("acct_name", bankCardVerifiVo.getAcctName(), ParamPosition.QUERY, false); apiRequest.addParam("acct_pan", bankCardVerifiVo.getAcctPan(), ParamPosition.QUERY, true); apiRequest.addParam("cert_id", bankCardVerifiVo.getCertId(), ParamPosition.QUERY, false); apiRequest.addParam("phone_num", bankCardVerifiVo.getPhoneNum(), ParamPosition.QUERY, false); return asyncClient.syncInvoke0(apiRequest); &#125; /** * &#123; * "resp": &#123; * "code": 0, * "desc": "匹配" * &#125;, * "data": &#123; * "photo": "/9j/4AAQSkZJRgABAgAAAQAzb0a9jtkMbHG/o3+19P89K28x...", * "address": "四川省雅安地区荥经县", * "sex": "M", * "birthday": "1989-9-28" * &#125; * &#125; * * 身份证实名认证--返照片 * https://market.aliyun.com/products/57000002/cmapi015194.html?spm=5176.2020520132.101.10.2lTTNI#sku=yuncode919400000 * @param idPhotoVo * @see AliHttpStatusEm * @see com.dotnar.usc.common.util.aliapi.idphoto.IdPhotoStatusEm * @return */ public ApiResponse syncIdphoto(IdPhotoVo idPhotoVo) &#123; ApiRequest apiRequest = new ApiRequest(Scheme.HTTP, Method.GET, Constant.ID_PHOTO_HOST, Constant.ID_PHOTO_API_PATH); apiRequest.addParam("cardno", idPhotoVo.getCardno(), ParamPosition.QUERY, true); apiRequest.addParam("name", idPhotoVo.getName(), ParamPosition.QUERY, true); return asyncClient.syncInvoke0(apiRequest); &#125;&#125; 常见的错误123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @Date 2017/12/5 16:42 * &lt;p&gt; * https://help.aliyun.com/document_detail/43906.html */public enum AliHttpStatusEm &#123; OK("OK", 200, "成功"), THROTTLED_BY_USER_FLOW_CONTROL("Throttled by USER Flow Control", 403, "因用户流控被限制"), THROTTLED_BY_APP_FLOW_CONTROL("Throttled by APP Flow Control", 403, "因APP流控被限制"), THROTTLED_BY_API_FLOW_CONTROL("Throttled by API Flow Control", 403, "因 API 流控被限制"), THROTTLED_BY_DOMAIN_FLOW_CONTROL("Throttled by DOMAIN Flow Control", 403, "因二级域名流控被限制，或因分组流控被限制"), QUOTA_EXHAUSTED("Quota Exhausted", 403, "调用次数已用完"), QUOTA_EXPIRED("Quota Expired", 403, "购买次数已过期"), USER_ARREARS("User Arrears", 403, "用户已欠费"), INVALID_ACCESS_KEY_ID_NOT_FOUND("InvalidAccessKeyId.NotFound", 404, "AccessKeyId 找不到"), INVALID_ACCESS_KEY_ID_INACTIVE("InvalidAccessKeyId.Inactive", 400, "AccessKeyId 被禁用。"), INVALID_TIME_STAMP_FORMAT("InvalidTimeStamp.Format", 400, "时间戳格式不对( Date 和 Timestamp)。"), INVALID_TIME_STAMP_EXPIRED("InvalidTimeStamp.Expired", 400, "用户时间和服务器时间超过15分钟。"), INVALID_SIGNATURE_METHOD("InvalidSignatureMethod", 400, "签名方法不支持。"), SIGNATURE_DOES_NOT_MATCH("SignatureDoesNotMatch", 400, "签名不通过。"), THROTTLING_USER("Throttling.User", 400, "用户调用频率超限。"), THROTTLING_API("Throttling.API", 400, "API 访问频率超限。"); /** * 错误码 */ private String code; /** * http 状态码 */ private int statusCode; /** * 中文描述 */ private String desc; private final static Map&lt;String, AliHttpStatusEm&gt; ID_MAP = Arrays.stream(AliHttpStatusEm.values()) .collect(Collectors.toMap(AliHttpStatusEm::getCode, Function.identity())); AliHttpStatusEm(String code, int statusCode, String desc) &#123; this.code = code; this.statusCode = statusCode; this.desc = desc; &#125; public String getCode() &#123; return code; &#125; public int getStatusCode() &#123; return statusCode; &#125; public String getDesc() &#123; return desc; &#125; public static AliHttpStatusEm getAliHttpStatusEmByStatusCode(String code) &#123; return ID_MAP.get(code); &#125;&#125; 银行卡验证错误状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 银行卡验证状态码 * * @author * @Date 2017/12/5 17:31 * &lt;p&gt; * https://market.aliyun.com/products/57000002/cmapi014429.html?spm=5176.2020520132.101.5.2lTTNI#sku=yuncode842900008 */public enum BankCardVerifiStatusEm &#123; OK((short) 0, "OK"), CARD_IS_FORFEITED((short) 4, "此卡被没收，请于发卡方联系"), CARDHOLDER_AUTHENTICATION_FAILED((short) 5, "持卡人认证失败"), INVALID_CARD_NUMBER((short) 14, "无效卡号"), CARD_DOES_NOT_CORRESPOND_ISSUER((short) 15, "此卡无对应发卡方"), CARD_IS_NOT_INITIALIZED_OR_SLEEPS((short) 21, "该卡未初始化或睡眠卡"), CHEAT_TUNKA((short) 34, "作弊卡，吞卡"), ISSUER_DOES_NOT_SUPPORT_TRANSACTION((short) 40, "发卡方不支持的交易"), CARD_HAS__REPORTED((short) 41, "此卡已经挂失"), CARD_IS_FORFEITED_2((short) 43, "此卡被没收"), CARD_HAS_EXPIRED((short) 54, "该卡已过期"), CARD_ISSUER_DOES_NOT_ALLOW_THIS_TRANSACTION((short) 57, "发卡方不允许此交易"), RESTRICTED_CARD((short) 62, "受限制的卡"), WRONG_NUMBER_OF_PASSWORDS((short) 75, "密码错误次数超限"), FAILED((short) 96, "交易失败，请稍后重试"); private short code; private String desc; private final static Map&lt;Short, BankCardVerifiStatusEm&gt; ID_MAP = Arrays.stream(BankCardVerifiStatusEm.values()) .collect(Collectors.toMap(BankCardVerifiStatusEm::getCode, Function.identity())); BankCardVerifiStatusEm(short code, String desc) &#123; this.code = code; this.desc = desc; &#125; public short getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; public static BankCardVerifiStatusEm getBankCardVerifiStatusEmByCode(short code) &#123; return ID_MAP.get(code); &#125;&#125; 获取 身份证照片12345678910111213141516171819202122232425262728293031323334353637383940/** * @author * @Date 2017/12/5 19:05 * https://market.aliyun.com/products/57000002/cmapi015194.html?spm=5176.2020520132.101.10.2lTTNI#sku=yuncode919400000 */public enum IdPhotoStatusEm &#123; OK((short) 0, "匹配"), MISMATCH((short) 5, "不匹配"), NOT_EXIST((short) 14, "无此身份证号码"), FAILED((short) 96, "交易失败，请稍后重试"); private short code; private String desc; private final static Map&lt;Short, IdPhotoStatusEm&gt; ID_MAP = Arrays.stream(IdPhotoStatusEm.values()) .collect(Collectors.toMap(IdPhotoStatusEm::getCode, Function.identity())); IdPhotoStatusEm(short code, String desc) &#123; this.code = code; this.desc = desc; &#125; public short getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; public static IdPhotoStatusEm getIdPhotoStatusEmByCode(short code) &#123; return ID_MAP.get(code); &#125;&#125;]]></content>
      <categories>
        <category>Gists</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成md5]]></title>
    <url>%2F120617%2Fjava-generate-md5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526public static String md5(String source)&#123; try &#123; MessageDigest md5 = MessageDigest.getInstance("MD5"); return bytesConvertToHexString(md5.digest(source.getBytes())); &#125;catch (Exception e)&#123; &#125; return null;&#125;/** * 把字节数组转化成字符串返回 * @param bytes * @return */public static String bytesConvertToHexString(byte [] bytes) &#123; StringBuffer sb = new StringBuffer(); for (byte aByte : bytes) &#123; String s= Integer.toHexString(0xff &amp; aByte); if(s.length()==1)&#123; sb.append("0"+s); &#125;else&#123; sb.append(s); &#125; &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>Gists</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter]]></title>
    <url>%2F120617%2F%2Fadapter%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/03_adapter 也被称为包装纸 意图将类的接口转换为客户端的另一个接口期望。适配器让班级一起工作，否则不能因为不兼容的接口。 说明真实世界的例子 请考虑您的存储卡中有一些照片，并且需要将它们传输到您的计算机上。为了传输它们，您需要一些与计算机端口兼容的适配器，以便您可以将存储卡连接到计算机。在这种情况下，读卡器是一个适配器。另一个例子是着名的电源适配器;一个三脚插头不能连接到双叉插座上，需要使用一个电源适配器，使其与双叉插座兼容。又一个例子是翻译者将一个人所说的话翻译成另一个人 用简单的话来说 适配器模式可让您将适配器中另外的不兼容对象包装在一起，以使其与另一个类兼容。 维基百科说 在软件工程中，适配器模式是一种软件设计模式，它允许将现有类的接口用作另一个接口。它通常用于使现有类与其他类一起工作而不修改其源代码。 编程示例 考虑一个只能使用划艇的船长，根本不能航行。 首先我们有界面RowingBoat和FishingBoat 12345678910public interface RowingBoat &#123; void row();&#125;public class FishingBoat &#123; private static final Logger LOGGER = LoggerFactory.getLogger(FishingBoat.class); public void sail() &#123; LOGGER.info("The fishing boat is sailing"); &#125;&#125; And captain expects an implementation of RowingBoat interface to be able to move 12345678910111213public class Captain implements RowingBoat &#123; private RowingBoat rowingBoat; public Captain(RowingBoat rowingBoat) &#123; this.rowingBoat = rowingBoat; &#125; @Override public void row() &#123; rowingBoat.row(); &#125;&#125; 现在让我们说，海盗来了，我们的船长需要逃跑，但只有渔船可用。 我们需要创建一个适配器，允许船长用他的划船技能来操作渔船。 123456789101112131415public class FishingBoatAdapter implements RowingBoat &#123; private static final Logger LOGGER = LoggerFactory.getLogger(FishingBoatAdapter.class); private FishingBoat boat; public FishingBoatAdapter() &#123; boat = new FishingBoat(); &#125; @Override public void row() &#123; boat.sail(); &#125;&#125; 现在“船长”可以用“渔船”逃出海盗。 12Captain captain = new Captain(new FishingBoatAdapter());captain.row(); 适用性使用适配器模式时 你想使用一个现有的类，它的接口不符合你所需要的 你想创建一个可重用的类，与不相关或不可预见的类进行合作，也就是说，不需要兼容接口的类 您需要使用几个现有的子类，但是通过继承每个子类来调整它们的接口是不切实际的。对象适配器可以调整其父类的接口。 大多数使用第三方库的应用程序使用适配器作为应用程序和第三方库之间的中间层，以将应用程序与库分离。如果必须使用另一个库，则只需要用于新库的适配器而不必更改应用程序代码。 后果：类和对象适配器有不同的权衡。类适配器 通过承诺一个具体的适应类来适应目标。因此，当我们想调整一个类及其所有子类时，类适配器将不起作用。 让我们的Adapter重写一些Adaptee的行为，因为Adapter是Adaptee的一个子类。 只引入一个对象，并且不需要额外的指针间接寻找适配器。 一个对象适配器 让我们一个适配器与许多适配器一起工作 - 即适配器本身及其所有子类（如果有的话）。适配器也可以一次为所有的适配器添加功能。 使覆盖Adaptee行为变得更加困难。这将需要子类Adaptee和使适配器指的是子类而不是适配器本身。 示例 java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter 参考 Design Patterns: Elements of Reusable Object-Oriented Software J2EE Design Patterns 原项目地址:https://github.com/iluwatar/java-design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Factory]]></title>
    <url>%2F120617%2Fabstract-factory%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/02_abstract-factory 也被称为套件 意图提供一个用于创建相关或相关系列的界面对象，而不指定具体的类。 说明真实世界的例子 要创造一个王国，我们需要有共同主题的物体。 精灵王国需要一个精灵王，精灵城堡和精灵军，而兽人王国需要一个兽人王，兽人城堡和兽人军。 王国中的物体之间有依赖关系。 用简单的话来说 工厂工厂; 一个工厂，将个别但相关/依赖的工厂分组在一起，而不指定具体的类别。 维基百科说 抽象工厂模式提供了一种方法来封装一组具有共同主题的单个工厂，而不指定具体的类 编程示例 翻译上面的王国的例子。 首先，我们有一些界面和实施的王国对象 12345678910111213141516171819202122232425262728293031323334public interface Castle &#123; String getDescription();&#125;public interface King &#123; String getDescription();&#125;public interface Army &#123; String getDescription();&#125;// Elven implementations -&gt;public class ElfCastle implements Castle &#123; static final String DESCRIPTION = "This is the Elven castle!"; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;public class ElfKing implements King &#123; static final String DESCRIPTION = "This is the Elven king!"; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;public class ElfArmy implements Army &#123; static final String DESCRIPTION = "This is the Elven Army!"; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;// Orcish implementations similarly... 然后我们有王国工厂的抽象和实现 1234567891011121314151617181920212223242526272829public interface KingdomFactory &#123; Castle createCastle(); King createKing(); Army createArmy();&#125;public class ElfKingdomFactory implements KingdomFactory &#123; public Castle createCastle() &#123; return new ElfCastle(); &#125; public King createKing() &#123; return new ElfKing(); &#125; public Army createArmy() &#123; return new ElfArmy(); &#125;&#125;public class OrcKingdomFactory implements KingdomFactory &#123; public Castle createCastle() &#123; return new OrcCastle(); &#125; public King createKing() &#123; return new OrcKing(); &#125; public Army createArmy() &#123; return new OrcArmy(); &#125;&#125; 现在我们有我们的抽象工厂，让我们做相关对象的家庭，即精灵王国工厂创造精灵城堡，国王和军队等。 12345678KingdomFactory factory = new ElfKingdomFactory();Castle castle = factory.createCastle();King king = factory.createKing();Army army = factory.createArmy();castle.getDescription(); // Output: This is the Elven castle!king.getDescription(); // Output: This is the Elven king!army.getDescription(); // Output: This is the Elven Army! 现在，我们可以为我们不同的王国工厂设计一个工厂。 在这个例子中，我们创建了FactoryMaker，负责返回ElfKingdomFactory或OrcKingdomFactory的一个实例。客户端可以使用FactoryMaker创建所需的哪一个具体的工厂，反过来，他们将生产不同的具体对象（军队，国王，城堡）。在这个例子中，我们也使用了一个枚举来参数化客户端要求的王国工厂的类型。 12345678910111213141516171819202122232425262728293031public static class FactoryMaker &#123; public enum KingdomType &#123; ELF, ORC &#125; public static KingdomFactory makeFactory(KingdomType type) &#123; switch (type) &#123; case ELF: return new ElfKingdomFactory(); case ORC: return new OrcKingdomFactory(); default: throw new IllegalArgumentException("KingdomType not supported."); &#125; &#125;&#125;public static void main(String[] args) &#123; App app = new App(); LOGGER.info("Elf Kingdom"); app.createKingdom(FactoryMaker.makeFactory(KingdomType.ELF)); LOGGER.info(app.getArmy().getDescription()); LOGGER.info(app.getCastle().getDescription()); LOGGER.info(app.getKing().getDescription()); LOGGER.info("Orc Kingdom"); app.createKingdom(FactoryMaker.makeFactory(KingdomType.ORC)); -- similar use of the orc factory&#125; 适用性使用抽象工厂模式时 一个系统应该独立于产品的创建，组成和代表 系统应配置多个产品系列中的一个 一系列相关产品对象被设计为一起使用，并且您需要强制执行此限制 你想提供一个产品类库，你只想揭示他们的接口，而不是他们的实现 依赖的生命周期在概念上比消费者的生命周期短。 您需要运行时值来构建特定的依赖关系 您想在运行时决定从家庭中调用哪个产品。 您需要提供一个或多个只在运行时已知的参数，然后才能解析相关性。 用例： 选择在运行时调用适当的FileSystemAcmeService或DatabaseAcmeService或NetworkAcmeService实现。 单元测试用例写作变得更容易 后果：java中的依赖注入隐藏了可能导致运行时错误的服务类依赖，这些错误在编译时会被捕获。 示例 javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 参考 Design Patterns: Elements of Reusable Object-Oriented Software 原项目地址:https://github.com/iluwatar/java-design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Document]]></title>
    <url>%2F120617%2Fabstract-document%2F</url>
    <content type="text"><![CDATA[https://github.com/mask-dmrs/java-design-patterns/tree/my-master/01_abstract-document 意图实现无类型语言的灵活性并保持类型安全 适用性使用抽象文档模式时 有需要动态添加新的属性 你想要一个灵活的方式来组织树状结构域 你想要更松散的耦合系统 参考 Wikipedia: Abstract Document Pattern Martin Fowler: Dealing with properties 原项目地址:https://github.com/iluwatar/java-design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中级难度</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性的处理]]></title>
    <url>%2F113017%2Fdealing-with-properties%2F</url>
    <content type="text"><![CDATA[属性的处理(初步校对) Martin Fowler (《重构：改善既有代码的设计》作者) fowler@acm.org 你创建的每个对象几乎都需要属性：关于对象的一些声明。一个人可能有一个身高属性，一个公司可能有一个CEO，一个航班可能有一个航班号。有很多方法来创建属性。在这篇文章中，我将探讨其中一些你经常需要用到的方法。我经常看到涉及到这个话题的图案，但他们通常只涉及一部分。在这里，我想更广泛地讨论这个问题，以便更好地讨论这些选项。 最常见和最简单的情况是使用固定属性，即只声明类的属性。在绝大多数情况下，你只需要使用固定属性。在有大量固定属性或者需要频繁修改时，使用固定属性容易出错。这种情况下你可能会使用动态属性。所有的动态属性都有一个参数化属性的特性：你需要一个带参的方法来查询一个属性。当参数只是一个字符串,最简单的是灵活的动态属性。这样定义和使用属性会比较容易，但难以控制。如果你需要使用动态属性，在你的参数必须是一个类的实例的情况下。使用类型动态属性来增强对动态属性的控制。 随着您的属性结构变得越来越复杂，您应该考虑将它们设置为“单独属性”，把一些属性综合起来创建一个对象。如果你需要多值属性，你可以考虑集合。在这篇文章中最复杂的例子是你想要规则来控制什么类型的对象具有什么样的属性 - 这需要一定的动态属性知识水平。 另一种属性完全是外部属性（Extrinsic Property），如果你想使用接口给一个对象创建一个属性，那么这就是你需要使用的一种模式。 问题 答案 名称 页码 &nbsp; 在编程语言里，当使用一个特定的属性，它需要查询或者更新。 固定属性 4 &nbsp; 提供可参数化的属性，可以根据参数表示不同的属性 动态属性 4 &nbsp; 提供一个用字符串参数化的属性。声明一个属性只是使用字符串. 灵活的动态属性 5 &nbsp; 提供用某种类型的实例参数化的属性。要声明属性，请创建该类型的新实例 定义动态属性 7 &nbsp; 提供使用某种类型的实例进行参数化的属性。要声明属性，请创建该类型的新实例并指定该属性的值类型. 类型动态属性 9 你如何表示一个对象的属性，并允许对象的属性也具有属性 为每个属性创建一个单独的对象。 关于那个属性的详细可以作为这个对象的的属性. 分离属性 10 你如何表示两个对象之间的关系（如何表示多个值动态属性？） 为两个对象之间的每个链接创建一个关系对象。 给关系对象一个类型对象来表示关系的含义。 （类型对象是多值属性的名称。） 类型关系 14 当你使用动态属性时，你如何强制某些类型的对象具有某些属性？ 创建知识级别以包含哪些类型的对象使用哪些类型的属性的规则 动态属性知识水平 16 你如何给一个对象新增一个属性而不改变它的接口？ 使用另一个对象负责属性 外在性质 18 什么是属性这不是一个愚蠢的问题。当人们使用“属性”这个词时，他们可能有很多不同的含义。对某些属性来说，是一个类的实例变量或数据成员。对于其他人来说，它们就像UML图中的一个盒子一样。所以在我开始这篇文章之前，我必须定义这个词的用法。 为了我的目的，一个属性是关于一个可以通过查询方法获得的对象的一些信息。它可能是一个值类型（如Java中的int）或一个类的实例。您可能能够修改该属性，但不一定。您可以在创建对象时设置属性，但不一定。该属性可以作为实例变量或数据成员存储，但不一定是。班级可能会从另一个班级获得值，或者经过一些进一步的计算。因此，我采用属性的接口视图而不是实现视图。这是我在设计中经常使用的习惯：对于我来说，面向对象的本质是将接口与实现分开，并使接口更加重要。 固定属性固定属性是我们使用的最常见的属性。 固定属性在类型的接口中声明。 它给出了属性的名称和返回类型。 图1显示了使用UML建模的属性，示例1显示了这些属性的查询方法如何在Java中使用。 我已经选择了这个例子来说明这个讨论同样适用于UML属性和UML关联。 它也适用于计算值（年龄）以及那些合理存储的数据（出生日期）。 图1.使用固定属性建模的人员1234567class Person &#123; public Date getDateOfBirth(); public int getAge(); public Quantity getHeight(); public Company getEmployer(); public void setDateOfBirth (Date newDateOfBirth); public void setEmployer (Company newEmployer); 列举,图1的java操作 查询操作通常遵循一些命名约定。在程序语言中，您总是在属性名称（dateOfBirth）之后命名查询。 C++从来没有一个固定的约定，有些人只是在属性后面命名，而另一些人则使用get约定（getDateOfBirth）。 Java从没有特别的约定开始，但现在大多数人都采用get约定。就我个人而言，当您阅读代码时，我发现get令人恼火，所以我宁愿忽略它，但Java风格是使用get，所以现在就使用它。无论您使用的是存储值还是派生值，都应确保遵循相同的约定。使用Person的客户端不应该知道或关心年龄是否存储或派生。 修饰符操作的存在取决于您是否希望直接修改值。如果你这样做，那么你会根据一些命名方案，例如setDateOfBirth（Date）提供一个修饰符操作。对于返回值存在不同的约定。你可以返回属性的新值（Date），被修改的对象（Person），或者什么都没有（void）。我更愿意在修饰符上返回void，以帮助明确修饰符和查询之间的区别。 固定属性 你如何代表一个对象的事实？ 给它一个这个事实的特定属性。这将转化为查询方法，并可能是一种编程语言的更新方法。接口很清晰明确只能在设计时添加属性 您可能希望为属性的构造函数提供参数。通常，您要在构造函数中设置足够的属性，以便构建格式良好的类。 不想直接修改的属性不应该有修饰符操作。如果您只希望从出生之日起计算，那么年龄属性可能就是这种情况。对于一个不可改变的属性也是如此：一个在类的生命周期中不会改变的属性。当你想使属性不可改变时，请记住考虑到人为错误。虽然出生日期对于现实世界中的人类来说是不可改变的属性，但是您可能会在输入到计算机系统时出现错误，从而使其变得可变。软件常常模拟我们所知道的世界，而不是世界本身。 固定属性是迄今为止您将遇到的最常见的属性形式。他们这样做是有原因的：他们使用简单方便。您应该使用固定属性作为表示属性的第一个也是最常见的选择。在本文中，我将给出许多固定属性的替代方案。在某些情况下，这些替代品更好，但大多数情况下不是。请记住，当我们经历的选择。我99％的时间使用固定的属性。其他品种更为复杂，这就是为什么我把这篇论文的大部分花费在他们身上 - 也是为什么我不愿意使用它们！ 动态属性固定属性的关键在于您在设计时修复了这些属性，并且所有实例在运行时都必须遵循该决定。 对于一些问题，这是一个尴尬的限制。 想象一下，我们正在建立一个复杂的联络系统。 有一些东西是固定的：家庭住址，家庭和工作电话，电子邮件。 但他们是各种各样的小变化。 对于需要记录父母地址的人，另一个人有白天工作和晚上工作号码。 事先很难预测所有这些事情，每次更改系统时都必须经过编译，测试和分发。 要处理这个问题，你需要使用动态属性。 动态属性 你如何代表一个对象的事实？ 提供可参数化的属性，可以根据参数表示不同的属性 可以在运行时添加属性 接口不清晰 动态属性有多种变化，每种变化都会在灵活性和安全性之间做出不同的选择。 最简单的方法是灵活动态属性。 这种模式的本质是为键值为简单值的人（通常是字符串）添加一个合格的关联（参见图2和示例2）。 如果您想为某人Kent添加休假地址，则只需使用清单3中的代码即可。您不需要重新编译人员类。 你甚至可以建立一个图形用户界面（GUI）或者文件读取器来添加属性，而不用重新编译客户端。 图2.使用动态属性建模的人员123class Person &#123; public Object getValueOf(String key); public void setValueOf(String key, Object value); 列举2,图2的java方法12kent.setValueOf(“VacationAddress”, anAddress);Address kentVactation = (Address) kent.getValueOf(“VacationAddress”) 列举3,使用动态属性这样说，你可能想知道为什么有人会使用固定的属性，因为动态的像这样的属性给了你更多的灵活性。当然有一个成本，它在于软件各部分之间依赖关系的清晰度降低。这一切都非常好给一个人增加一个度假地址属性，但是你怎么知道把它重新取回呢？有了固定的属性，你可以看看人的界面，看看属性。该编译器可以检查不要求对象做不理解的事情。 用一个动态属性，你不能做任何设计时检查。此外的界面人很难看。不只是你看Person的声明接口 -你也必须找到不会出现在类接口中的动态属性。你必须找到那些设置属性的代码部分（通常不会在Person类中）提现出来。 灵活动态属性 你如何代表一个对象的事实？ 提供一个用字符串参数化的属性。只声明一个属性使用字符串。 不仅是属性很难找到，它的依赖也是一个噩梦。随着固定属性的客户端代码有一个依赖于人类 - 一个依赖是难以跟踪。如果你改变属性的名字，编译器会让你知道，并告诉你需要改变什么代码才能解决问题。但灵活的动态属性创建一个依赖于任意一段代码。它可能是属于一个类的代码甚至不能被客户端看到。如果有人更改密钥字符串会发生什么？如果有人改变他们把键入字符串的对象的类型会发生？不仅仅是编译器没法帮助你，你甚至不知道从哪里开始查找变化。 灵活的动态属性在最极端的情况下显示了这个问题。 该属性可能是Person的任何客户端在设计时创建。 如果另一个人的客户端使用同一个属性，那么你就很难找到两个类之间的依赖关系。 此外属性可以在运行时通过读取文件或通过GUI添加。 即使在运行时，不可能发现一个人的哪些动态属性是合法的。 当然，你可以问一个人，如果它有一个度假地址的属性 - 但如果没有一个这是否意味着这一点人没有假期地址，或者是否意味着没有这样的度假地址属性？ 而如果现在没有这样的属性，那并不意味着它几秒钟后不会有。 灵活动态特性的另一个关键缺点是很难替代它们进行操作。封装的一个关键优势是使用属性的客户端无法分辨它是作为对象数据的一部分存储的，还是通过方法来计算的。这是一个对象方法非常重要的一部分。它可以让你不只是一个普通的接口实现，而且在客户端不知情的情况下改变你期望的值。当存在子类型，你甚至可以有一个超类型存储属性和子类计算，反之亦然。但是，如果要使用动态属性，则只能更改存储的数据一个计算就是在通用访问器中为动态属性设置一个特定的数值,清单4中的代码。这个代码可能很脆弱，难以维护。 1234567class Person &#123; public Object getValueOf (String key) &#123; if (key = “vacationAddress”) return calculatedVacationAddress(); if (key = “vacationPhone”) return getVacationPhone(); // else return stored value… 列举4,用操作替换动态属性 其他形式的动态属性可以帮助您解决其中一些问题，但不是全部。该动态属性的最大的缺点是：你失去了清晰的接口和所有的设计时间检查。动态属性的不同方法会让你额外写不同的检查方法。如果你需要动态属性，并且当然有确定的情况你这样做，那么你只需要放弃设计时间检查和明确的设计时间接口。唯一的问题是如何明确接口和有多少运行时检查。使用灵活的动态属性也会有同样的问题。 你经常在数据库中发现动态属性，因为改变它通常是一个痛苦数据库模式，特别是如果有大量的数据迁移。分布式的接口例如在CORBA中的组件也经常因为相似的原因而使用动态属性。那里是很多使用界面的远程客户，所以你不愿意改变它。在这两种情况下，编译时和运行时间之间的区别并不是设计时和生产之间的区别。 如果你正在做的是通过GUI显示和更新信息，而代码永远不会对键进行固定的引用（即，你永远不会看到像清单3那样的代码），那么使用灵活动态属性就非常安全。这是因为你没有设置一个任意字符串作为一个关键的讨厌的依赖。 否则，你应该考虑动态属性的其他方法之一。 更多运行时检查的第一步是定义的动态属性。与灵活动态属性相反，定义的关键区别在于动态属性使用的关键字不再是一些任意的字符串，而是现在某个类的一个实例（图3）。 图3.定义的动态属性 在它的表面上使用定义的动态属性并没有太大的改变。事实上，代码界面几乎完全相同（清单5和清单6）。但是现在，关键字的选择不再是完全随意的，而是受到接触类型的限制。当然，这仍然允许您在运行时添加属性-只需创建一个新的关联类型。不过现在至少在某个地方可以找到一个潜在的键列表，而无需浏览程序代码。 在设计时添加的任何键都可以在关联类型类的加载程序中收集。您可以轻松地提供服务，以在运行时查找合法的键。 123class Person &#123; public Object getValueOf(ContactType key); public void setValueOf(ContactType key, Object value); 列举5, 图3的Java接口1234class ContactType &#123; public static Enumeration instances(); public static boolean hasInstanceNamed(String name); public static ContactType get(String name); 列举6,为定义的属性类型提供的服务 你现在可以设置一些检查来防止由于某人要求一个不存在的动态属性而导致的错误。我在这里抛出一个未经检查的异常，因为我认为get（）的前提条件是客户端为联系人类型提供合法名称。客户端总是可以通过使用hasInstanceNamed（）来执行这个检查，但是大多数情况下客户端使用的是类型而不是字符串。 定义动态属性 你如何代表一个对象的事实？ 提供用某种类型的实例参数化的属性。声明一个属性创建一个新类型的实例 通常，联系人类型将保存在字典中，通常由字符串索引。这个字典可能是一个静态的联系人类型的字段，但是我更愿意把它作为注册服务器上的字段。 删除联系人类型仍然具有尴尬的后果。在java中的动态属性仍然会出现在那些拥有它们的对象上，除非你写了一些复杂的东西清理代码。我通常会规定永远不要删除动态属性的键。如果你想使用一个新的名字，你可以通过给它一个其他名字，但是把它放置在定义的字典中几次，很容易地为联系类型添加别名。 1234567class ContactType &#123; public static ContactType get(String name) &#123; if (! hasInstanceNamed (name)) throw new IllegalArgumentException(“No such contact type); // return the contact type&#125;// use withAddress kentVactation = (Address)kent.getValueOf(ContactType.get(“VacationAddress”)); 列举7, 检查使用合法合同类型 在这一点上，您可能想知道这与概念建模有什么关系，毕竟我写了很多代码并讨论了设计的权衡。这是一个重要的概念问题，因为您所做的概念选择会影响您的实现选择。如果你选择在你的概念模型中使用灵活动态属性，你很难在你的实现中使用定义的动态属性或固定属性。你做概念模型的原因之一是探索你的用户的概念是什么固定的，什么是可变的。如果全面的灵活性是我唯一的目标，那么我会总是使用图4.通过这个，我可以模拟世界上的任何情况。但是这个模型不是很有用。它在现实项目中是没用的，它不表示什么是固定的。什么时候你正在做一个概念模型，你需要知道你的选择如何影响项目实施-否则你失去了作为建模者的作用。 我经常发现人们发现动态属性，然后想要在任何地方使用它们。灵活性如此之大，他们获得了所有的可扩展性。是的，有时候你需要动态属性。但永远不会忘记有一个标准。只有当你真的使用它们需要他们才用。毕竟，如果必须使用，以后很容易添加它们。 图4.一个可以无用建模任何域的模型 定义动态属性允许您更多地指出你拥有的属性。这些属性仍然是无类型的。您不能强制图3中休假地址的值是一个地址。 你可以通过使用类型动态属性来做些什么。 图5.为使用限定关联的类型化动态属性建模 类型动态属性将类型信息添加到定义的动态属性（图6和6）图5）。这里的联系人类型的实例不只是指出该人是什么合适的人有，他们也表示每个属性的类型。 类型约束的值，沿线清单9。 123456class Person &#123; public Object getValueOf(ContactType key); public void setValueOf(ContactType key, Object value);class ContactType &#123; public Class getValueType(); public ContactType (String name, Class valueType); 列举8, 键入动态属性的操作 12345class Person &#123; public void setValueOf(ContactType key, Object value) &#123; if (! key.getValueType().isInstance(value)) throw IllegalArgumentException (“Incorrect type for property”); // set the value 列举9, 做类型检查 这样做类型检查可以帮助避免错误，但它仍然不像固定属性那样清晰。 检查是在运行时，而不是在设计时，因此不是有效的。但还是比没有检查好，特别是如果你习惯于强类型的环境时。 类型动态属性 你如何代表一个对象的事实？ 提供使用某种类型的实例进行参数化的属性。声明一个属性创建一个新类型的实例并指定值的类型属性。 当我们深入研究动态属性时，我们会发现更丰富的反射示例，这是一种架构模式，当我们获得能够描述自身的运行时对象时，就会出现这种模式。 [POSA]比我打算在这里更详细地讨论反思。 动态属性提供反射功能，即使在那些不支持反射的语言中。即使使用了一种能够提供一些反射的语言，动态属性的反射也更加集中 - 所以您可以提供更易于使用的接口。 使用所有这些合格的关联可能会很难遵循。另一种方式提供类型动态属性是使用单独的属性模式。独立属性模式的本质是它使属性成为一个对象（图6和清单10）。 你可以获得一个人的属性，然后与每个属性获得值和类型信息。 分离属性 你如何代表一个对象的属性，并允许属性记录这个属性 为每个属性创建一个单独的对象。有关该属性的子属性可以然后被做成那个对象的属性。 独立属性和限定的关联动态属性总是可用的两种选择。 到目前为止，我已经用限定的关联描述了灵活的和定义好的动态属性，因为合格的关联提供了一个更容易使用的接口。如果你愿意的话，你可以使用灵活和定义的具有单独属性的动态属性，尽管我不打算进入在这里。当我们了解类型化动态属性的复杂性时，分离属性风格变得更有优势。 图6.为分类的动态属性建模，使用单独的属性 123456class Person &#123; public Enumeration getProperties();class ContactProperty &#123; public Object getValue(); public Class getType(); public ContactType getIndex(); 列举10, 使用单独属性的类型化动态属性的操作 分离属性和有限的关联不是相互排斥的。您可以轻松地同时提供两个接口。 这样你就得到了两者的优点。当然这会使接口更加复杂，所以先考虑一下用户的需求。给他们提供他们需要的接口，不要让接口变得复杂。但是，如果他们需要合格的关联和分离属性，那么这是一个合理的选择。我通常会使用合格的关联来获得值，但是这种类型可能没有多大意义。 您也可以在这里考虑接口/实现的差异。在本文中，我想集中在概念上 - 它映射到软件的接口而不是实现。但值得一提的是，您可以在实现中使用单独的对象时提供合格的关联接口。如果人的客户端可以获取联系人属性对象，则只能在接口中使用单独的属性。通常隐藏分离属性以简化客户端的接口是有用的。 分离属性的一大优势是它可以让你把属性的信息放在属性中。 这些信息可能包括谁确定了属性，什么时候确定了属性等。 [Fowler AP§3.5]中的观察模式基于这个主题进行了深入的研究。如果您需要单独的属性，我在观察者模式所描述的大部分内容都值得思考。（我将观察模式看作是使用不同的属性。） 您可能想知道分离属性（模式）和限定关联（UML建模结构）之间的对比。 你也可以把合格的关联看作一种模式，一种联想模式。确实，我在[Fowler AP §15.2]中做了这个。我发现为设计创建模型考虑是有帮助的，因为它帮助我思考使用它们的权衡。当你将它们的模型比较清楚，如分离属性，这是特别有用的。当然，以模式开始的事情可以转化为建模结构，特别是如果使用UML构造型。历史映射模式[FowlerAP§15.3]就是一个很好的例子。我表示使用这种模式非常刻版。这是一个模式或建模？也许这是一个地板蜡和一个沙漠顶部。 具有多值关联的动态属性我上面的例子集中讨论了动态属性中每个键都有一个单一值的情况。 但是，您也可以在动态属性中有多个事件的情况。与人相处时，你可能会考虑一个多值的友好属性。处理这个问题有两种方法，一种简单而不令人满意，另一种令人满意，但（太）复杂。 简单的方法就是说动态属性的值可以是一个集合。然后我们可以像使用相同接口的其他对象一样操作它（清单11）。这很好，很简单，因为我们不需要对基本的动态属性模式做任何事情（这里的例子是一个类型化的动态属性，但是它可以和所有的模式一起工作）。然而，这并不令人满意，因为它不是真的是我们想要处理多值属性的方式。如果朋友是一个固定的属性，我们需要一个接口，如清单12所示。我不喜欢在这些情况下暴露集合。通过这样做，人员班级在我们添加或移除元素时就失去了应对的能力。这也消除了我们改变我们正在使用的集合类型的能力。 1234567Person aPerson = new Person();ContactType friends = new ContactType(“Friends”, Class.forName(“Vector”));Person martin = new Person(“Martin”);martin.setValueOf(“Friends”, new Vector());Person kent = new Person(“Kent”);martin.getValueOf(“Friends”).addElement(“Kent”);Enumeration friends = martin.getValueOf(“Friends”).elements(); 列举11, 在类型化动态属性中使用集合值1234class Person &#123; public Enumeration getFriends(); public void addFriend(Person arg); public void removeFriend(Person arg); 列举12, 一个固定的多值属性的运作 那么当我们有动态属性的时候，我们可以按照清单12的方式获得一个接口吗？ 那么，如果我们努力工作，就可以如图7所示。但这是一个复杂的模型。 通过一些巧妙的编码，我们可以隐藏接口（清单13和清单14）背后的大部分复杂性，并且使用起来相当方便（清单15）。但客户端仍然需要知道哪些属性是单值的，哪些属性是多值的，并且只有在运行时才能检查正确的使用情况。所有这些复杂性都是痛苦的-比使用固定属性更痛苦。我会非常不愿走这么远。 图7.满足对多值动态属性的过度支持 123456789101112class Person public Object getValueOf(ContactType key); public Enumeration getValuesOf(ContactType key); public void setValueOf(ContactType key, Object newValue); public void addValueTo(ContactType key, Object newValue); public void removeValueFrom(ContactType key, Object newValue); class ContactType public Class getValueType(); public boolean isMultiValued(); public boolean isSingleValued(); public ContactType(String name, Class valueType, boolean isMultiValued); 列举13, 图7的操作 12345678910111213class Person public Object getValueOf(ContactType key) &#123; if (key.isMultiValued()) throw IllegalArgumentException(“should use getValuesOf()”) //return the value &#125; public void addValueTo(ContactType key, Object newValue) &#123; if (key.isSingleValued()) throw IllegalArgumentException(“should use setValueOf”); if (! key.getValueType().isInstance(newValue)) throw IllegalArgumentException (“Incorrect type for property”); //add the value to the collection 列举14, 检查清单13的操作的使用情况 123456fax = new ContactType(“fax”, Class.forName(“PhoneNumber”), false);Person martin = new Person(“martin”);martin.setValueOf(“fax”, new PhoneNumber(“123 1234”);martinFax = martin.getValueOf(“fax”);friends = new ContactType (“friends”, Class.forName(“Person”), true);martin.addValueTo(“friends”, new Person(“Kent”)); 列举15, 使用清单13的操作 这种复杂性似乎是因为我们既有多值也有单值的属性。处理这些复杂性有一个内在的不同的接口，因此复杂性也是如此。当然，我们可以得到只有多值属性的情况。一个常见的模式是类型关系模式（图8）。在这里，一个人可能与许多不同公司有不同的雇佣关系（甚至与同一家公司有多个）。 图8.类型关系的一个例子 12345678class Employment &#123; public Employment (Person person, Company company, Employment Type type); public void terminate() …&#125;class Person &#123; public Enumeration getEmployments(); public void addEmployment (Company company, EmploymentType type); 列举16, 图8的Java接口 正如我们想到的那样，很快就会发现，这与使用多值的定义动态属性非常类似，但是使用分离属性而不是合适的关联来表示。（或者说这句话太过分了？）实际上，图9显示了在这种情况下如何使用定义动态属性接口。这种事物的观点是真实的，所以一个类型化的关系不会添加任何新的模式语言。 但是类型化关系在建模圈子中是一种非常普遍的模式，很多人可能没有意识到它与动态属性模式的联系。 类型关系 你如何表示两个对象之间的关系？（你如何表示多值动态属性？） 为两个对象之间的每个链接创建一个关系对象。 给关系对象一个类型对象来表示关系的含义。（类型对象是多值属性的名称。） 类型化关系的优势在于它可以很好地处理双向关系，并且为关系添加属性提供了一个简单的点。（当然，后者是一个分离属性的特征。）你可以在这个模式中添加一个复杂的知识级别，跟类型化的动态属性一样。但是，您应该考虑接口的影响。类型化关系迫使用户意识到雇佣对象，因为确实使用分离属性。事实上，人们倾向于将属性客体本身看作完全成熟的客体，而不是人（或公司）的一些属性。 但是合格的关联通常可以为许多目的提供更简单的接口。所以每当你看到，或者你正在考虑使用，一个类型的关系;你还应该考虑合格的关联形式。您可以在任何一个方向或两个方向上使用它，也可以将其用于除了键入的关系之外，或者除此之外。。 但是这两种模式并不完全相同。如果使用图9，则表示雇主只能是某种特定工种的雇主。图8在图表中没有这样的约束，尽管大多数建模者会暗示这样的约束，除非雇用具有附加属性。当然，就业通常具有附加属性。一个常见的例子是日期范围（如问责制[Fowler，AP§2.4]）。 图9.使用与图8相同情况的合格关联 123public Person &#123; public void addEmployer (Company company, EmploymentType type); public Enumeration getEmployersOfType (EmploymentType type); 列举17, 图9的接口 图10.键入的关系，显示通常假定的约束 不同种类的人到目前为止，我们假设我们只有一种人，我们为一个人定义的任何属性都是所有人的有效属性。但是，您确实会遇到不同类型的情况，以及不同类型的不同属性。管理人员可能需要一个管理部门的属性，执行人员可能需要一个属性作为高管卫生间的关键号码（在一个不是90年代的公司）。 别担心，我听到“使用继承愚蠢”的呼声。事实上，这是常用于分类的情况之一。实际上，这个过程比这个要复杂得多，特别是当你开始思考一个人可能扮演的角色时。我已经写了关于建模角色[Fowler roles]的主题的全文。角色模式考虑了我们对操作变化和固定属性变化感兴趣的情况。但在这种情况下，我想探索不同类型的对象与动态属性的概念的重叠。这种重叠会导致动态属性知识级别模式（一个对我的品味有点太大的名字）。 为了使用这个模式，我们给Person一个Person类型的类型对象。然后，我们可以说，人物类型与联系人类型的关联指示哪些人物拥有该人物类型可用的属性。 如果我们尝试使用或要求某人的属性，则可以使用人员类型来检查使用情况是否正确。 图11.动态属性知识水平 1234567class Person &#123; public Object getValueOf(ContactProperty key); public boolean hasProperty(ContactProperty key); public void setValueOf(ContactProperty key, Object newValue);class PersonType &#123; public boolean hasProperty(ContactProperty key); public Enumeration getProperties(); 列举18, 图11的操作12345class Person &#123; public Object getValueOf (ContactProperty key) &#123; if (!hasProperty(key)) throw IllegalArgumentException(“Innapropriate key”); //return the value 列举19, 检查具有动态属性知识级别的适当的密钥 当我们开始使用这样的知识水平时，单独的属性变得越来越重要。 在这种情况下，我们很快就会开始停止将其视为一种属性，而不是把它作为一个对象。 什么是属性和什么是非属性之间的分界线是非常模糊的，这实际上取决于你对事物的看法。 动态属性知识水平 你如何执行某些类型的对象具有某些特性使用动态属性？ 创建一个知识级别来包含什么类型的对象使用的规则哪些类型的属性 动态属性的几个小结各种各样的动态属性构成了本文的大部分内容。但我必须重申，动态属性是我想要尽可能避免的。动态属性带来了很大的负担：接口不够清晰，使用操作而不是存储数据的困难。只是有时你别无选择，只能使用它们，在这种情况下，这篇论文应该有用的给你提供一些替代方案和之间的权衡。 动态属性出现在改变接口有困难的地方。那些使用像他们这样的分布式对象系统的人，至少在原则上是这样，因为它允许他们在不改变客户端的情况下改变接口 - 而在分布式系统中，可能很难找到你的客户端。但是你仍然应该警惕这样做。每当你为动态属性添加一个新的键到你的键上，你都在有效地改变接口。所有的动态属性都在替换运行时检查的编译时间检查。你仍然有同样的问题保持你的客户端最新。 动态属性的另一个常见用途是在数据库中。这里不仅仅是由于接口的问题，而且由于数据迁移的问题（如果不是主要的话）。更改数据库模式不仅会导致对使用该模式的程序进行潜在更改，还可能会强制您执行复杂的数据转换练习。同样，动态属性允许您在不更改数据库模式的情况下更改内容，从而不需要进行任何数据转换。在大型数据库中，这可能是一个引人注目的优势。 一个你不知道的有关于属性的我想在本文中添加一个最后一个重要的属性。这是一个没有意识到属性的对象的情况。当属性被另一个对象所隐含，以及与有关的方式时，就会发生这种情况。 考虑一个管理数据库连接的对象。它会创建一堆数据库连接，并在请求时将它们传递给其他对象。当一个客户端连接完成后，可以将其返回给管理员，以供其他人使用。您可以通过向连接添加isBusy属性来完成此操作。图12显示了一个使用外部属性的替代方案。连接是空闲的还是繁忙的是由连接管理器中的哪个集合决定的。如果你有一个连接，你不能问它是空闲的还是忙的，而是你必须要求连接管理器是否特定的连接空闲或忙碌。你可以这样说，因为组合关联是一种方式。连接不知道连接管理器。 从某种意义上来说，空闲/忙碌状态根本不是连接的属性。但至少从某种意义上来说，这就是我提到它的原因。 图12.使用外部收集属性 在纯粹的概念模型意义上，这种模式没有多大意义。但是，为什么你可能想要使用它，有实际的实施原因。如果您希望对此属性进行的所有更改都通过连接管理器进行，则此方法可以清楚地说明这一点。特别是当你想让连接管理器给你一个自由的连接，而你不关心哪一个时，这是一种自然的风格。。 使用外部属性的另一个原因是如果连接类是由其他人提供的，并且您不能更改其接口。 你可以添加新的属性而不用改变连接类。 外在属性 你如何给对象一个属性而不改变它的接口？ 让另一个对象负责知道这个属性。 外在属性的一个大问题是它会导致一个尴尬和不自然的接口。通常如果你想知道一些东西，你只要找到合适的对象并提出问题。在这里您需要找到保存外部集合的对象，并询问有关适当的对象。在某些情况下，比如这个，似乎是合理的。但大多数情况下，我宁愿让对象了解自己的属性（在这种情况下，我称之为内在属性）。 最后的想法当我完成本文时，我觉得需要再次敦促你不要使用我在这里写的东西，除非你真的需要它。固定属性的好处是伟大的。如果你需要别的东西，那么我希望这篇文章能给你一些想法和一些指导。但固定属性永远是你的第一选择。 参考[Fowler, AP] Fowler, Martin. Analysis Patterns: Reusable Object Models, Addison-1997[Fowler, roles] Fowler, Martin. Dealing with Roles,http://www.awl.com/cseng/titles/89542-0/awweb.htm[POSA] Buschman et al, Pattern Oriented Software Architecture, Wiley 1997 原文地址：http://martinfowler.com/apsupp/properties.pdf]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>属性</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP扫描二维码登陆流程]]></title>
    <url>%2F111417%2Fap-scan-two-dimensional-code-landing-proces%2F</url>
    <content type="text"><![CDATA[流程 客户端页面请求二维码(带有客户端标识和操作标识),这个二维码实际上来自安全中心的后台生成.(二维码状态:待扫描),此时信息需要放在redis里面保存起来 客户端页面获取到二维码之后,轮询客户端后台,查看这个标识的状态. 安全中心APP(已登录)扫描客户端前台生成的二维码,然后将识别出来的信息获取后访问安全中心后台,安全中心后台将当前APP用户的唯一标示和当前的二维码信息绑定,回调客户端后台.(二维码状态:已扫描) 安全中心APP上操作是否确认,然后改变当前二维码标示(二维码状态:已同意或已拒绝) 客户端前台轮询到已扫描可以提示用户确认,轮询到已同意可直接系统自动登录(通过绑定的用户唯一标识获取到用户加密的密码,走正常的登录流程,).成功之后注意清空密码信息. 二维码生成工具12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 图片由ProcessOn生成]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>登陆</tag>
        <tag>APP</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo集成gitment异常处理]]></title>
    <url>%2F110917%2Fhexo-integrated-gitment-exception-handling%2F</url>
    <content type="text"><![CDATA[问题集成Gitment按照官方的文档配置报错Cannot read property &#39;firstChild&#39; of null 查找 通过页面的异常进入js发现是获取某个对象为空gitment-container 讲这个关键词在插件里面搜索发现,这个一个装载留言内容的div,于是在异常的页面查看源码搜索,没有找到这个div. 通过查看源码发现themes\next\layout\_third-party\comments是一个留言的插件集合,包含多种留言插件js文件12345678&#123;% include 'duoshuo.swig' %&#125;&#123;% include 'disqus.swig' %&#125;&#123;% include 'hypercomments.swig' %&#125;&#123;% include 'youyan.swig' %&#125;&#123;% include 'livere.swig' %&#125;&#123;% include 'changyan.swig' %&#125;&#123;% include 'gitment.swig' %&#125;&#123;% include 'valine.swig' %&#125; themes\next\layout\_partials是留言插件html文件comments.swig有一段代码引起我的注意1234567891011121314&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="SOHUCS"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 对照themes\next\_config.yml文件12345678changyan: enable: false appid: XX appkey: XXgitment: enable: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway mint: false 要命的是之前是用畅言测试过,但是这里不是根据changyan.enable去判断,于是导致ifelse进入了畅言这个留言插件的div判断. 解决 清空themes\next\_config.yml文件中的changyan.appid和changyan.appkey,themes\next\layout\_partials\comments.swig文中,theme.changyan.appid and theme.changyan.appkey修改为theme.changyan.enable 总结 规范开发 善于关键词查找分析解决问题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>gitment</tag>
        <tag>Hexo</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件或主题修改记录]]></title>
    <url>%2F110617%2Fplug-in-or-topic-modification-records%2F</url>
    <content type="text"><![CDATA[短路径利于Seo 修改文章默认路径原来是YYYY改为YY文件路径%HEXO_HOME%lib\plugins\filter\post_permalink.js,方法postPermalinkFilter中的meta的year属性. 代码块颜色不够显眼 修改默认的灰色为红色,文件路径\themes\next\source\css\_variables\base.styl 150 行 $code-foreground = $black-light 改为 $code-foreground = $red 151 行 $code-background = $gainsboro 改为 $code-background = $gray-lighter 持续更新中…]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高房价背后的真实逻辑（深度长篇分析）]]></title>
    <url>%2F110517%2Fthe-real-logic-behind-the-high-house-price-(a-long-analysis-of-the-depth)%2F</url>
    <content type="text"><![CDATA[这篇文章不做好和坏的价值判断，只谈现象背后的逻辑和规律。我会向你表达我真实的看法，但文章的结论可能会有点残酷。要不要往下读，取决于你自己。但我相信，尽早看清现实，早做打算，能够帮助你在人生的关键路口做出正确的判断。 01马太效应（强者愈强，弱者愈弱）是世间最冰冷的规则，却又无处不在。2015年，公众号“城市数据团”发表了一篇爆文《逃离你终将衰落的家乡》。文章以各省人口流动的大数据（2005年-2010年）为依据，得出了一个残酷的结论： 大都市就像抽水机，不停地从落后省份抽取劳动力，或许将来的某一天，我们就会像今天的日本一样，无数村庄和城镇凋零衰败，但东京和大阪都市圈繁华依旧。 大都市将毫不留情地吸干周边地区的血液，以便自己能够生存。残酷吗？不，因为这是年轻劳动力自己用脚（投票）投出的结果。 （图片来自“城市数据团”） 而由人口迁徙引申出来的推论，则更加触目惊心： 你还能在这些选择（逃离北上广还是逃回北上广）中犹豫，说明你无比幸福，因为你们的下一代和下下一代可能不会再有任何选择的机会。假如你最终选择留在了一个生活安逸风景如画的小城镇上，你也许会幸福地过完一生；但在你的子女到了你这个年纪的时候，很可能他们有且只有一个选择，那就是——逃离他们终将衰落的家乡。 我曾在《社会即将分层，你将会在第几层？》一文中引用了“城市数据团”的分析结论。 当时有一些人对结论持怀疑和反对态度，因为他们相信政府调控的力量。 政府一边限定了特大城市的常驻人口指标，一边强调要引导中心城市人口向周边转移（如某部委印发了《全国国土规划纲要》）。 控制特大城市规模，让各个区域平衡发展是政府调控的目标。 那么，现实情况又是怎样？ 揭开答案前，先来看看日本的情况。 日本有三个地方GDP特别高，那就是东京、名古屋和大阪，这三个地方的GDP加起来，占全日本GDP总量的80%以上，所以这三个地方又被称为日本的三大都市圈。 根据日本总务省2014年公布的数据，三大都市圈人口总数高达6439.33万人，占日本全国总人口的50.93%， 到了2017年，这个数据变成了6453.26万人，人口数占比达到了51.38%。 也就是说，哪怕是在人口负增长的国家，人们依然在源源不断地向发达地区聚集。 这就是人口的聚集效应。 中国聚集效应则更加明显。 今年年初，“城市数据团”发布了文章《曾经熟悉的家乡终将成为倍感孤独的地方》。文章根据2014年-2016年春运大数据，再次揭示了这个残酷的事实： 相比于2005-2010年期间的数据，最近3年全国人口流动的集聚程度仍然在进一步地提高。 大城市的人口抽血能力并没有减缓，反而在持续地加强。 更多地方的人们愿意跋涉更远的距离，承担更高的成本，以逃离他们的家乡。 （一线城市从全国人口抽血盛况） （准一线城市抽血地图） 为什么会这样？ 有网友给出了这样的答案： 人向大城市集中，因为大城市有更多的就业机会，有更好的发展，比如做IT的，就要往北上杭深走；但是，很少有大城市的人走向小城市去，因为小城市有的，大城市基本也有。另外，交通的发展也导致了大城市对小城市人员的吸引，在前些年高铁热的时候，基本所有的地方政府都认为高铁来了，钱就到了，但更多的是，高铁来了，人就走了。具体到我们家来说，县里只有几家大企业，能做的是制造业、商业这些，但这些需要的工人较多，走出去的大学生很少去做这个；另一方面，你在外读书期间习惯了大城市的生活，读书馆、电影院、博物馆、书店、游乐场，县里没有啊。 很多人误以为政府的调控是无所不能的，他们错了。 社会运行自有其内在规律。 人口迁移遵循聚集效应，社会发展遵循马太效应。 大都市拥有优质的政治资源、商业资源、教育资源、人力资源……这些优质资源吸引着无数优秀的年轻人，而优秀的年轻人将推动大都市的繁荣发展，从而让大都市获取更多的资源，于是形成了一个优势迭代的良性循环，这就是马太效应中的强者愈强。 然而，大都市在攫取优秀人才的同时，也在用高额的房价和户籍制度将千千万万的普通人挤到繁华都市的边缘，将他们赶到逼仄的地下室，脏乱的出租房，直到他们梦碎的那一天，收起行囊，滚回家乡，然后他们的下一代再背起行囊，逃离家乡。 这就是马太效应的另一面，弱者愈弱。 这听起来非常残酷，却又无比现实。 02前几天我发起了关于房价的意见征集，有一位读者给我留言说： 我们在北京的时候年收入近50万买不起房子，后果就是举家撤离，再也无法享受北京的生活便利、以及包括医疗和教育在内的各种资源。离开北京一年了，和其他地方相比，感觉北京除了房子贵，其他都是相当便宜的！现在后悔得很，买不起房直接导致我和孩子们命运轨迹的改变！所以，在北京，只要有预估能力，就应该贷款买房！ 这条留言指出了房子的真正价值。 当你买房的时候，买的并不仅仅是一个遮风避雨的居住场所，还包括周边提供的医疗、教育、交通、娱乐、公用服务以及发展机遇。 比如说，北大的很多课程都是对外开放的，如果你住在北大边上，你可以免费享受中国最顶尖的教育资源。 再拿学区房为例。 很多人说，天价学区房是国人的焦虑感和功利性心态造就的，但他们不知道，学区房的概念其实起源于美国。 吴军老师在他的专栏写过一篇文章《怎么看名校毕业生在北京买不起学区房》，里面有这样一段介绍： 美国好学区的房价和差学区的房价差别比中国要厉害得多，很多时候，隔着一条街，房价可以差几倍。在硅谷中心的帕罗阿图市（Palo Alto虽然叫做城市，但它只有两万人，相当于中国的一个小镇），处于中值水平的独栋房房价在300万美元以上，而和它只隔着一条马路的东帕罗阿图中位数房价只有60-80万美元左右。 这两个区的差别有多大呢？一边住着拉里·佩奇、扎克伯格，以及很多斯坦福的教授，过去乔布斯也在那里，另一边是很多中低收入的墨西哥裔居民，包括不少非法移民。 在美国，没有人觉得这种划分学区的方法有什么不好，因为大家习惯了。但是久而久之，学区好的地方聚集着比较体面、富有的一些家庭，不好的学区，整个条件都比较差，这是一个事实，而且很长时间几乎没有改变过。 万维钢老师在《美国教育各阶层分析》一文中也提到了类似的观点： 美国是个有严重阶层区分的国家，各社区按房价自然分开，在某种意义上是事实上的种族和贫富隔离。公立中小学的经费主要由所在学区的房产税而来，这意味着两点：第一，富人区的学校更有钱，可以请更好的老师、用更好的设备、有更高的教学水平；第二，学生们其实是在跟自己同阶层的人一起上学。 教育资源不是标注品，必定有高下之分，而优质的教育资源永远是稀缺的。 学区房的出现，本质上是一种教育资源的分配方案。 当你买下学区房的时候，买的是下一代接受良好教育的入场券。 03“房子是用来住的，不是用来炒的。” 今年的大会，这句话非常鼓舞人心。 但有太多人误解了这句话。 其完全的表述是： “坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、租购并举的住房制度，让全体人民住有所居。” 什么叫多渠道保障？ 什么叫租购并举？ 什么叫让你住有所居？ 大会只承诺了房子的居住功能，并没有承诺你可以轻易地拥有房屋的产权，更没有承诺你能拥有房子背后的隐性价值。 其实早在去年3月的时候，发改委主任就曾提出：现在我国租房比例太低，购和租要并举。 政策的大方向是要推广房屋租赁，而不是让你买得起房。 是政府不重视民生问题吗？ 并不是。 先来看看国外的情况。 根据欧盟统计局2014年的数据，欧盟28国的所有人口中，有近三成(29.9%)的人是租房子住的，其中德国的租房比例达到了47.5%，仅52.5%的人居住在自有住房内。 也就是说，将近一半的德国人都是租房的。 美国的情况也是类似。 根据皮尤研究中心的一项调查显示，2006年，57%的35岁以下家庭是租房子居住的。到了2016年，这个比例已经提高到了65% 把年龄放宽一点，35至44岁的美国家庭中，租房的比例依然高达41%。 这还只是平均数据，如果把目光聚焦到全球范围内的一线城市，当地人拥有住房的比例更低。 比如德国的首都柏林，住房拥有率只有15.6%，有将近85%的人都只能租房子住。 （图片来自公众号“财经连环话”） 再来看看我们的春运人口迁移图你就会明白： 中国的人口基数太大了，但大城市的土地资源是有限的。 在有限的土地上，怎么可能满足所有人在大城市买房的需求？ 唯有加快推广租赁。 从这一点来讲，租售并举的政策大方向是没错的。 但连带提出的“租售同权”则纯粹是在画大饼了。 04今年7月，一篇名为《突发，楼市巨变！广州宣布：租售同权》的文章突然刷屏了，原因是广州出台了《关于印发广州市加快发展住房租赁市场工作方案的通知》，通知里有这么一句话： “赋予符合条件的承租人子女享有就近入学等公共服务权益，保障租购同权。” 于是那篇爆文的作者这样解读道： 从今天开始，中国的买房终于和教育资源脱钩了，没有房，小孩照样可以上学了。 这绝对是一次历史创举，具体未来的影响可能远超我们的想象，但绝对是我们现在无法估量的。 但就像我在前面说了，学区房的本质是一种教育资源的分配方案。 在教育资源没有变多，而大城市人口还在不断聚集的情况下，“租售同权”完全是个伪概念。 当适龄的报名儿童超过学校招生计划时，学校会怎么做？ 杭州就有关于“一表生”、“二表生”的录取规则。 即学校应该根据学龄儿童户籍和家庭住宅情况，按照“住、户一致”优先原则，按下面四种先后顺序录取： 05楼市有泡沫吗？ 有啊，但不在一线城市，而是在三四五六线城市。 2016年和2017年经历了两波房价的暴涨，但这两波的性质是不同的。 2016年的那波暴涨，是因为实业资本转移到了一二线城市的楼市，推高了房价，随后炒房团涌入，再次推高房价，但钱都是流向大城市的。 但2017年这一波就不一样了。 因为2016年的这波暴涨，政府开始调控了。 42个大城市（截止9月23日）先后出台了限售、限购等政策，炒房团买不了房了，于是纷纷涌向了三四线城市。 但是，在三四线城市： 有优质的教育资源吗？ 有优质的医疗服务吗？ 有丰富的娱乐场所吗？ 有良好的公共服务吗？ 有广阔的发展机遇吗？ 都没有。 这不过是一场击鼓传花的游戏。 最后接盘的那些投机客，他们将会为自己炒高房价的行为付出代价。 06经济学家马光远提出过楼市的后视镜原理： 从房价的基本规律看，在一个国家城市的人口净增加，一个国家的人口转折点没有到来，以及一个国家的人均GDP尚未超越中等收入水平的情况下，资产价格长期的趋势仍然是向上的，无一例外。今天看到的资产价格的高点，明天很可能只是半山腰而已。 回顾过去20年中国房价，站在当时的时空下，每年都觉得房价很高，但回过头看，那些以前认为高不可攀的价格，现在看起来是不是很便宜？ 这就是房价的“后视镜”原理。 只要中国的经济持续向前发展，大城市的房子就依然会升值。 这里的大城市，是指四个一线城市及杭州、南京、苏州等几个重点二线城市。 这些大城市的房价中，包含了教育、医疗、交通、娱乐、公共服务、发展机遇等隐性价值，正是这些隐性价值支撑着其高昂的房价。 要记住一点：优质的资源永远是稀缺的，稀缺的资源永远是昂贵的。 土地的总量是有限的，而想要定居大城市的人是源源不断的。 大城市好地段的房子是有形且有限的资源，买房的本质就是占有资源。 还要记住的一点是：财富是以家庭为单位的。 我以前写过这么一段话： 年轻人可以不靠父母在大城市买房吗？ 对于70后而言，这样的想法叫志气；对于80后而言，想要实现靠机遇；对于90后而言，如果还抱着这样的想法，只能说是学生气。 如果你的家庭有足够的实力，我强烈建议你们尽早在一线城市买房。 如果负担太大，也可以退而求其次，在重点二线城市买。 中国未来的房价地图也会围绕三大都市圈和个别的交通枢纽城市展开。或许短期内房价会波动，但从长期看，依然会升值。 这是我的判断，并且我对自己的判断很有信心。 如果你的家庭无法支撑起你在一二线城市买房，你也可以有两种选择： 在大城市租房打拼，我知道这样会很辛苦，但多少会给你带来改一点变命运的机会。 回到你的家乡，那里有你童年的记忆和年迈的父母亲戚，但可能没有你孩子的未来（原因见人口的流动）。 （有网友说，这就像一群没核的红细胞从肢体末端蜂拥至心脏） 这两个选择没有对错，但每种选择都有其代价，而人生，则是一个又一个选择叠加起来的总和。 十年后你所站立的地方，你下一代所站立的起点，都是你今天的选择所带来的结果。 P.s 关于房价，其实还有很多因素可以讲，比如土地供应、货币超发等等，但这些都不是决定性因素，而且这篇文章已经快6000字了，就不再多说了。 关于中国的三大都市圈和个别的交通枢纽城市，我会另写一篇。 再P.s **总有人问，为什么每次越调控房价涨得越快。 其实他们是把因果关系搞反了。 并不是因为调控导致房价上涨，而是房价本来就要往上涨，但政府通过各种手段（限价、限售等）强行暂停了房价的上涨。所以一旦调控放开之后，房价立即就会补涨。** 对于房价的管制，北大的薛兆丰老师有一个比喻： 你仅仅按住价格，并不能改变价格背后的现实。这好比你管不住温度，却非要去管温度计一样荒唐。 再再P.s 《魔鬼经济学》中有一句话我印象非常深刻： “如果说伦理道德代表了我们心目中理想的社会运行模式的话，那么经济学就是在向我们描述这个社会到底是如何运行的。” 很多时候，我们乐于相信生活应该是什么样子的，但沉溺在自己的理想世界并不能解决任何问题，看清现实，早做打算，才是对自己的人生负责。 这篇文章虽然一点也不温暖，甚至有点冷漠，但我相信看完后它会对你有所帮助。 转载自 雪球 资本x时代]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>生活</tag>
        <tag>房子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制位运算实例]]></title>
    <url>%2F103117%2Fbinary-bit-operation-example%2F</url>
    <content type="text"><![CDATA[二进制位运算实例问题设计多选题的选项问题,一道题有多个选项ABCD,可能有更多如何设计更有效存储识别? 分析选项只有选与不选的区别,而且总的个数固定,而且判定2个结果是否存在(答案是否正确),二进制完全满足条件. 结果单个选项12345A：1 1B: 1 &lt;&lt; 1 2C: 1 &lt;&lt; 2 4D: 1 &lt;&lt; 3 8... 组合选项123AB： 1|2BC: 2|4ABCD: 1|2|4|8 比较答案正确答案 ABC : 1|2|4 --&gt; 7 用户选择 AB : 1|2 --&gt; 3 运算 3!=7 &amp;&amp; 3|7=7 说明部分答对 用户选择 BD : 2|8 --&gt; 10 运算 10!=7 &amp;&amp; 10|7=!7 说明有错误选项 相关知识Java位运算(移位、位与、或、异或、非）]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二进制</tag>
        <tag>Java基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InvalidClassException]]></title>
    <url>%2F103117%2Finvalidclasexception%2F</url>
    <content type="text"><![CDATA[InvalidClassException背景项目使用的SpringBoot架构,使用的是默认的Redis存储登陆信息 过程添加了一个有关于UsUser的接口,需要把当前登录信息返回给前端。 结果访问时InvalidClassException异常12org.springframework.data.redis.serializer.SerializationException: Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.InvalidClassException: com.usc.core.model.UsUser; local class incompatible: stream classdesc serialVersionUID = -4391106051528831723, local class serialVersionUID = -3047559744731102659 at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize(JdkSerializationRedisSerializer.java:82) 思考&amp;总结看到这个的第一反应是有人修改了serialVersionUID,然后发现这个类并没有这个字段.然后联想到这个信息是从redis获取的然后清理了redis中的登陆信息,异常不再出现.最后注意到这个org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.deserialize,已证明联想正确,出现问题到解决5分钟不到. 相关知识serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-config client不能连接server]]></title>
    <url>%2F103017%2Fspringcloud-config-client-canot-conect-to-server%2F</url>
    <content type="text"><![CDATA[错误详情 config clientjava代码1new SpringApplicationBuilder(Application.class).properties("spring.cloud.config.enabled:true").web(true).run(args); yml配置123456789spring: application: name: masque cloud: config: uri: http://localhost:8888 profile: dev label: final enabled: true 依赖12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 出现的问题官方示例中不需要配置 spring.cloud.config.enabled默认是true现在的情况是必须配置这两个enabled,否则client不会去找server 项目正常启动,没有任何异常 解决办法在对照了所有的java代码,翻阅了网上的一些博客发现,client多了一个依赖spring-cloud-config-server 去掉这个就正常了]]></content>
      <categories>
        <category>Java相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员]]></title>
    <url>%2F102217%2Fprogramer%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;公司最值钱的东西是产品，如果要问比产品更有价值的是什么？我认为是实实在在做事情的程序员们。 &ensp;&ensp;&ensp;&ensp;他们虽然工资不高，每天坐在位置上敲着代码，在很多人眼中被称为“屌丝”或“宅男”，但我认为恰恰就是这些人，他们才是公司最有价值的人。 &ensp;&ensp;&ensp;&ensp;他们有自己的理想，希望能够通过自己的努力，从中得到那一点点所谓的成就感。他们需要理解产品经理真正的意图，把想法变成现实，让产品真正落地。他们更容易把握细节，而这些细节往往决定着产品的命运与成败。他们突如其来的跳槽，对我们的项目的交付有直接的影响。他们在一起工作的气氛，能体现技术公司的文化与底蕴。由此看来，对程序员的重视是相当有必要的，我们需要关心每一位程序员的职业发展，让他们在团队里能够充分地发挥出自己的能力。 &ensp;&ensp;&ensp;&ensp;我们也需要对他们倍加关注，挖掘出有能力、肯吃苦、敢担当的人，给他们更多的机会，让他们成为技术领袖。 &ensp;&ensp;&ensp;&ensp;互联网技术公司需要大量这样的程序员： 他们是一群有着技术信仰的人，他们是一群热爱编程的人，他们是一群不解决问题睡不好觉的人。 他们不是打杂的，不是外包，更不是工具。 他们不喜欢被忽悠，不喜欢被冷落，更不喜欢被驱动。 他们需要尊重，需要培养，更需要激情！ 转载自 开源社区 黄勇的博客]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
